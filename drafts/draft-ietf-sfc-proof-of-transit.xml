<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml2rfc.tools.ietf.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC7665 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6830 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6830.xml">
<!ENTITY RFC6833 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6833.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC791 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC6564 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6564.xml">
<!ENTITY I-D.brockners-inband-oam-data SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.brockners-inband-oam-data.xml">
<!ENTITY I-D.brockners-inband-oam-requirements SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.brockners-inband-oam-requirements.xml">
<!ENTITY I-D.brockners-inband-oam-transport SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.brockners-inband-oam-transport.xml">
<!ENTITY I-D.brockners-proof-of-transit SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.brockners-proof-of-transit.xml">
<!ENTITY I-D.ietf-spring-segment-routing SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-spring-segment-routing.xml">
<!ENTITY I-D.draft-ietf-anima-autonomic-control-plane SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-anima-autonomic-control-plane-18.xml">
<!ENTITY I-D.previdi-isis-segment-routing-extensions SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.previdi-isis-segment-routing-extensions.xml">
<!ENTITY I-D.ietf-ippm-6man-pdm-option SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ippm-6man-pdm-option.xml">
<!ENTITY I-D.gont-v6ops-ipv6-ehs-in-real-world SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.gont-v6ops-ipv6-ehs-in-real-world.xml">
<!ENTITY I-D.brockners-lisp-sr SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.brockners-lisp-sr.xml">
<!ENTITY I-D.hildebrand-spud-prototype SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY I-D.ietf-sfc-nsh SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-sfc-nsh.xml">
<!ENTITY I-D.ietf-6man-segment-routing-header SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-6man-segment-routing-header.xml">
<!ENTITY I-D.ietf-nvo3-vxlan-gpe SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-nvo3-vxlan-gpe.xml">
<!ENTITY I-D.lapukhov-dataplane-probe SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.lapukhov-dataplane-probe.xml">
<!ENTITY I-D.SPUD SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY AFI SYSTEM "http://www.iana.org/assignments/address-family-numbers/address-family-numbers.xml">
]>
<!-- Comments received
Tal Mizrahi [mailto:talmi@marvell.com]
To summarize my take on this thread:
The proposed mechanism has two significant vulnerabilities that (in my understanding) are currently not addressed:
1.       A man-in-the-middle can replace the POT of packet A with the POT of packet B.
2.       It is possible to replay POTs within a certain time window, whose length is determined by the timestamp resolution.
 
-->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml2rfc.tools.ietf.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-ietf-sfc-proof-of-transit-01"
     ipr="trust200902">
  <!-- ipr="full3978"-->

  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="Proof of Transit">Proof of Transit</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Frank Brockners" initials="F." surname="Brockners">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Hansaallee 249, 3rd Floor</street>

          <!-- Reorder these if your country does things differently -->

          <city>DUESSELDORF</city>

          <region>NORDRHEIN-WESTFALEN</region>

          <code>40549</code>

          <country>Germany</country>
        </postal>

        <email>fbrockne@cisco.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>Bangalore, KARNATAKA 560 087</city>

          <country>India</country>
        </postal>

        <email>shwethab@cisco.com</email>
      </address>
    </author>

    <author fullname="Sashank Dara" initials="S." surname="Dara">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>BANGALORE</city>

          <region>Bangalore, KARNATAKA 560 087</region>

          <code></code>

          <country>INDIA</country>
        </postal>

        <phone></phone>

        <facsimile></facsimile>

        <email>sadara@cisco.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Carlos Pignataro" initials="C." surname="Pignataro">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>7200-11 Kit Creek Road</street>

          <city>Research Triangle Park</city>

          <region>NC</region>

          <code>27709</code>

          <country>United States</country>
        </postal>

        <email>cpignata@cisco.com</email>
      </address>
    </author>

    <author fullname="John Leddy" initials="J." surname="Leddy">
      <organization abbrev="Comcast">Comcast</organization>

      <address>
        <email>John_Leddy@cable.comcast.com</email>
      </address>
    </author>

    <author fullname="Stephen Youell" initials="S." surname="Youell">
      <organization abbrev="JPMC">JP Morgan Chase</organization>

      <address>
        <postal>
          <street>25 Bank Street</street>

          <city>London</city>

          <code>E14 5JP</code>

          <country>United Kingdom</country>
        </postal>

        <email>stephen.youell@jpmorgan.com</email>
      </address>
    </author>

    <author fullname="David Mozes" initials="D." surname="Mozes">
      <organization></organization>

      <address>
        <postal>
          <street></street>

          <city></city>

          <region></region>

          <code></code>

          <country></country>
        </postal>

        <phone></phone>

        <facsimile></facsimile>

        <email>mosesster@gmail.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Tal Mizrahi" initials="T." surname="Mizrahi">
      <organization>Marvell</organization>

      <address>
        <postal>
          <street>6 Hamada St.</street>

          <city>Yokneam</city>

          <region></region>

          <code>20692</code>

          <country>Israel</country>
        </postal>

        <phone></phone>

        <facsimile></facsimile>

        <email>talmi@marvell.com</email>

        <uri></uri>
      </address>
    </author>

    <author fullname="Alejandro Aguado" initials="A." surname="Aguado">
      <organization>Universidad Politecnica de Madrid</organization>

      <address>
        <postal>
          <street>Campus Montegancedo, Boadilla del Monte</street>

          <city>Madrid</city>

          <region></region>

          <code>28660</code>

          <country>Spain</country>
        </postal>

        <phone>+34 910 673 086</phone>

        <email>a.aguadom@fi.upm.es</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Diego R. Lopez" initials="D.R." surname="Lopez">
      <organization>Telefonica I+D</organization>

      <address>
        <postal>
          <street>Editor Jose Manuel Lara, 9 (1-B)</street>

          <city>Seville</city>

          <region></region>

          <code>41013</code>

          <country>Spain</country>
        </postal>

        <phone>+34 913 129 041</phone>

        <email>diego.r.lopez@telefonica.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date day="1" month="October" year="2018" />

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- OAM data Declarations -->

    <area>ops</area>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>Telemetry, Tracing, Proof of Transit</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>Several technologies such as Traffic Engineering (TE), Service
      Function Chaining (SFC), and policy based routing are used to steer
      traffic through a specific, user-defined path. This document defines
      mechanisms to securely prove that traffic transited said defined path.
      These mechanisms allow to securely verify whether, within a given path,
      all packets traversed all the nodes that they are supposed to visit.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Several deployments use Traffic Engineering, policy routing, Segment
      Routing (SR), and Service Function Chaining (SFC) <xref
      target="RFC7665"></xref> to steer packets through a specific set of
      nodes. In certain cases, regulatory obligations or a compliance policy
      require operators to prove that all packets that are supposed to follow
      a specific path are indeed being forwarded across and exact set of
      pre-determined nodes.</t>

      <t>If a packet flow is supposed to go through a series of service
      functions or network nodes, it has to be proven that indeed all packets
      of the flow followed the path or service chain or collection of nodes
      specified by the policy. In case some packets of a flow weren't
      appropriately processed, a verification device should determine the
      policy violation and take corresponding actions corresponding to the
      policy (e.g., drop or redirect the packet, send an alert etc.) In
      today's deployments, the proof that a packet traversed a particular path
      or service chain is typically delivered in an indirect way: Service
      appliances and network forwarding are in different trust domains.
      Physical hand-off-points are defined between these trust domains (i.e.
      physical interfaces). Or in other terms, in the "network forwarding
      domain" things are wired up in a way that traffic is delivered to the
      ingress interface of a service appliance and received back from an
      egress interface of a service appliance. This "wiring" is verified and
      then trusted upon. The evolution to Network Function Virtualization
      (NFV) and modern service chaining concepts (using technologies such as
      Locator/ID Separation Protocol (LISP), Network Service Header (NSH),
      Segment Routing (SR), etc.) blurs the line between the different trust
      domains, because the hand-off-points are no longer clearly defined
      physical interfaces, but are virtual interfaces. As a consequence,
      different trust layers should not to be mixed in the same device. For an
      NFV scenario a different type of proof is required. Offering a proof
      that a packet indeed traversed a specific set of service functions or
      nodes allows operators to evolve from the above described indirect
      methods of proving that packets visit a predetermined set of nodes.</t>

      <t>The solution approach presented in this document is based on a small
      portion of operational data added to every packet. This "in-situ"
      operational data is also referred to as "proof of transit data", or POT
      data. The POT data is updated at every required node and is used to
      verify whether a packet traversed all required nodes. A particular set
      of nodes "to be verified" is either described by a set of secret keys,
      or a set of shares of a single secret. Nodes on the path retrieve their
      individual keys or shares of a key (using for e.g., Shamir's Secret
      Sharing scheme) from a central controller. The complete key set is only
      known to the controller and a verifier node, which is typically the
      ultimate node on a path that performs verification. Each node in the
      path uses its secret or share of the secret to update the POT data of
      the packets as the packets pass through the node. When the verifier
      receives a packet, it uses its key(s) along with data found in the
      packet to validate whether the packet traversed the path correctly.</t>
    </section>

    <section anchor="Conventions" title="Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>

      <t>Abbreviations used in this document:</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="HMAC:">Hash based Message Authentication Code. For
          example, HMAC-SHA256 generates 256 bits of MAC</t>

          <t hangText="IOAM:">In-situ Operations, Administration, and
          Maintenance</t>

          <t hangText="LISP:">Locator/ID Separation Protocol</t>

          <t hangText="LPC:">Lagrange Polynomial Constants</t>

          <t hangText="MTU:">Maximum Transmit Unit</t>

          <t hangText="NFV:">Network Function Virtualization</t>

          <t hangText="NSH:">Network Service Header</t>

          <t hangText="POT:">Proof of Transit</t>

          <t hangText="POT-profile:">Proof of Transit Profile that has the
          necessary data for nodes to participate in proof of transit</t>

          <t hangText="RND:">Random Bits generated per packet. Packet fields
          that donot change during the traversal are given as input to
          HMAC-256 algorithm. A minimum of 32 bits (left most) need to be used
          from the output if RND is used to verify the packet integrity. This
          is a standard recommendation by NIST.</t>

          <t hangText="SEQ_NO:">Sequence number initialized to a predefined
          constant. This is used in concatenation with RND bits to mitigate
          different attacks discussed later.</t>

          <t hangText="SFC:">Service Function Chain</t>

          <t hangText="SR:">Segment Routing</t>
        </list></t>
    </section>

    <section title="Proof of Transit">
      <t>This section discusses methods and algorithms to provide for a "proof
      of transit" for packets traversing a specific path. A path which is to
      be verified consists of a set of nodes. Transit of the data packets
      through those nodes is to be proven. Besides the nodes, the setup also
      includes a Controller that creates secrets and secrets shares and
      configures the nodes for POT operations.</t>

      <t>The methods how traffic is identified and associated to a specific
      path is outside the scope of this document. Identification could be done
      using a filter (e.g., 5-tuple classifier), or an identifier which is
      already present in the packet (e.g., path or service identifier, NSH
      Service Path Identifier (SPI), flow-label, etc.)</t>

      <t>The solution approach is detailed in two steps. Initially the concept
      of the approach is explained. This concept is then further refined to
      make it operationally feasible.</t>

      <section title="Basic Idea">
        <t>The method relies on adding POT data to all packets that traverse a
        path. The added POT data allows a verifying node (egress node) to
        check whether a packet traversed the identified set of nodes on a path
        correctly or not. Security mechanisms are natively built into the
        generation of the POT data to protect against misuse (i.e.
        configuration mistakes, malicious administrators playing tricks with
        routing, capturing, spoofing and replaying packets). The mechanism for
        POT leverages "Shamir's Secret Sharing" scheme <xref
        target="SSS"></xref>.</t>

        <t>Shamir's secret sharing base idea: A polynomial (represented by its
        coefficients) is chosen as a secret by the controller. A polynomial
        represents a curve. A set of well-defined points on the curve are
        needed to construct the polynomial. Each point of the polynomial is
        called &ldquo;share&rdquo; of the secret. A single secret is
        associated with a particular set of nodes, which typically represent
        the path, to be verified. Shares of the single secret (i.e., points on
        the curve) are securely distributed from a Controller to the network
        nodes. Nodes use their respective share to update a cumulative value
        in the POT data of each packet. Only a verifying node has access to
        the complete secret. The verifying node validates the correctness of
        the received POT data by reconstructing the curve.</t>

        <t>The polynomial cannot be constructed if any of the points are
        missed or tampered. Per Shamir's Secret Sharing Scheme, any lesser
        points means one or more nodes are missed. Details of the precise
        configuration needed for achieving security are discussed further
        below.</t>

        <t>While applicable in theory, a vanilla approach based on Shamir's
        secret sharing could be easily attacked. If the same polynomial is
        reused for every packet for a path a passive attacker could reuse the
        value. As a consequence, one could consider creating a different
        polynomial per packet. Such an approach would be operationally
        complex. It would be complex to configure and recycle so many curves
        and their respective points for each node. Rather than using a single
        polynomial, two polynomials are used for the solution approach: A
        secret polynomial which is kept constant, and a per-packet polynomial
        which is public. Operations are performed on the sum of those two
        polynomials - creating a third polynomial which is secret and per
        packet.</t>
      </section>

      <section title="Solution Approach">
        <t>Solution approach: The overall algorithm uses two polynomials:
        POLY-1 and POLY-2. POLY-1 is secret and constant. Each node gets a
        point on POLY-1 at setup-time and keeps it secret. POLY-2 is public,
        random and per packet. Each node generates a point on POLY-2 each time
        a packet crosses it. Each node then calculates (point on POLY-1 +
        point on POLY-2) to get a (point on POLY-3) and passes it to verifier
        by adding it to each packet. The verifier constructs POLY-3 from the
        points given by all the nodes and cross checks whether POLY-3 = POLY-1
        + POLY-2. Only the verifier knows POLY-1. The solution leverages
        finite field arithmetic in a field of size &ldquo;prime
        number&rdquo;.</t>

        <t>Detailed algorithms are discussed next. A simple example is
        discussed in <xref target="toy-example"></xref>.</t>

        <section title="Setup">
          <t>A controller generates a first polynomial (POLY-1) of degree k
          and k+1 points on the polynomial. The constant coefficient of POLY-1
          is considered the SECRET. The non-constant coefficients are used to
          generate the Lagrange Polynomial Constants (LPC). Each of the k
          nodes (including verifier) are assigned a point on the polynomial
          i.e., shares of the SECRET. The verifier is configured with the
          SECRET. The Controller also generates coefficients (except the
          constant coefficient, called "RND", which is changed on a per packet
          basis) of a second polynomial POLY-2 of the same degree. Each node
          is configured with the LPC of POLY-2. Note that POLY-2 is
          public.</t>
        </section>

        <section title="In Transit">
          <t>For each packet, the ingress node generates a random number
          (RND). It is considered as the constant coefficient for POLY-2. A
          cumulative value (CML) is initialized to 0. Both RND, CML are
          carried as within the packet POT data. As the packet visits each
          node, the RND is retrieved from the packet and the respective share
          of POLY-2 is calculated. Each node calculates (Share(POLY-1) +
          Share(POLY-2)) and CML is updated with this sum. This step is
          performed by each node until the packet completes the path. The
          verifier also performs the step with its respective share.</t>
        </section>

        <section title="Verification">
          <t>The verifier cross checks whether CML = SECRET + RND. If this
          matches then the packet traversed the specified set of nodes in the
          path. This is due to the additive homomorphic property of Shamir's
          Secret Sharing scheme.</t>
        </section>
      </section>

      <section anchor="toy-example" title="Illustrative Example">
        <t>This section shows a simple example to illustrate step by step the
        approach described above.</t>

        <section title="Basic Version">
          <t>Assumption: It is to be verified whether packets passed through 3
          nodes. A polynomial of degree 2 is chosen for verification.</t>

          <t>Choices: Prime = 53. POLY-1(x) = (3x^2 + 3x + 10) mod 53. The
          secret to be re-constructed is the constant coefficient of POLY-1,
          i.e., SECRET=10. It is important to note that all operations are
          done over a finite field (i.e., modulo prime).</t>

          <section title="Secret Shares">
            <t>The shares of the secret are the points on POLY-1 chosen for
            the 3 nodes. For example, let x0=2, x1=4, x2=5.</t>

            <t><list style="empty">
                <t>POLY-1(2) = 28 =&gt; (x0, y0) = (2, 28)</t>

                <t>POLY-1(4) = 17 =&gt; (x1, y1) = (4, 17)</t>

                <t>POLY-1(5) = 47 =&gt; (x2, y2) = (5, 47)</t>
              </list></t>

            <t>The three points above are the points on the curve which are
            considered the shares of the secret. They are assigned to three
            nodes respectively and are kept secret.</t>
          </section>

          <section title="Lagrange Polynomials">
            <t>Lagrange basis polynomials (or Lagrange polynomials) are used
            for polynomial interpolation. For a given set of points on the
            curve Lagrange polynomials (as defined below) are used to
            reconstruct the curve and thus reconstruct the complete
            secret.</t>

            <t><list style="empty">
                <t>l0(x) = (((x-x1) / (x0-x1)) * ((x-x2)/x0-x2))) mod 53 =
                <vspace blankLines="0" />(((x-4) / (2-4)) * ((x-5)/2-5))) mod
                53 = <vspace blankLines="0" />(10/3 - 3x/2 + (1/6)x^2) mod
                53</t>

                <t>l1(x) = (((x-x0) / (x1-x0)) * ((x-x2)/x1-x2))) mod 53 =
                <vspace blankLines="0" />(-5 + 7x/2 - (1/2)x^2) mod 53</t>

                <t>l2(x) = (((x-x0) / (x2-x0)) * ((x-x1)/x2-x1))) mod 53 =
                <vspace blankLines="0" />(8/3 - 2 + (1/3)x^2) mod 53</t>
              </list></t>
          </section>

          <section title="LPC Computation">
            <t>Since x0=2, x1=4, x2=5 are chosen points. Given that
            computations are done over a finite arithmetic field ("modulo a
            prime number"), the Lagrange basis polynomial constants are
            computed modulo 53. The Lagrange Polynomial Constant (LPC) would
            be 10/3 , -5 , 8/3.</t>

            <t><list style="empty">
                <t>LPC(x0) = (10/3) mod 53 = 21</t>

                <t>LPC(x1) = (-5) mod 53 = 48</t>

                <t>LPC(x2) = (8/3) mod 53 = 38</t>
              </list>For a general way to compute the modular multiplicative
            inverse, see e.g., the Euclidean algorithm.</t>
          </section>

          <section title="Reconstruction">
            <t>Reconstruction of the polynomial is well-defined as</t>

            <t><!-- To ensure equations are on separate line for
				 readability --> POLY1(x) = l0(x) * y0 + l1(x) * y1 + l2(x) * y2</t>

            <t>Subsequently, the SECRET, which is the constant coefficient of
            POLY1(x) can be computed as below</t>

            <t>SECRET = (y0*LPC(l0)+y1*LPC(l1)+y2*LPC(l2)) mod 53</t>

            <t>The secret can be easily reconstructed using the y-values and
            the LPC:</t>

            <t>SECRET = (y0*LPC(l0) + y1*LPC(l1) + y2*LPC(l2)) mod 53 = mod
            (28 * 21 + 17 * 48 + 47 * 38) mod 53 = 3190 mod 53 = 10</t>

            <t>One observes that the secret reconstruction can easily be
            performed cumulatively hop by hop. CML represents the cumulative
            value. It is the POT data in the packet that is updated at each
            hop with the node's respective (yi*LPC(i)), where i is their
            respective value.</t>
          </section>

          <section title="Verification">
            <t>Upon completion of the path, the resulting CML is retrieved by
            the verifier from the packet POT data. Recall that verifier is
            preconfigured with the original SECRET. It is cross checked with
            the CML by the verifier. Subsequent actions based on the
            verification failing or succeeding could be taken as per the
            configured policies.</t>
          </section>
        </section>

        <section anchor="enhanced-version" title="Enhanced Version">
          <t>As observed previously, the vanilla algorithm that involves a
          single secret polynomial is not secure. Therefore, the solution is
          further enhanced with usage of a random second polynomial chosen per
          packet.</t>

          <section title="Random Polynomial">
            <t>Let the second polynomial POLY-2 be (RND + 7x + 10 x^2). RND is
            a random number and is generated for each packet. Note that POLY-2
            is public and need not be kept secret. The nodes can be
            pre-configured with the non-constant coefficients (for example, 7
            and 10 in this case could be configured through the Controller on
            each node). So precisely only RND value changes per packet and is
            public and the rest of the non-constant coefficients of POLY-2
            kept secret.</t>
          </section>

          <section title="Reconstruction">
            <t>Recall that each node is preconfigured with their respective
            Share(POLY-1). Each node calculates its respective Share(POLY-2)
            using the RND value retrieved from the packet. The CML
            reconstruction is enhanced as below. At every node, CML is updated
            as</t>

            <t>CML = CML+(((Share(POLY-1)+ Share(POLY-2)) * LPC) mod Prime</t>

            <t>Let us observe the packet level transformations in detail. For
            the example packet here, let the value RND be 45. Thus POLY-2
            would be (45 + 7x + 10x^2).</t>

            <t>The shares that could be generated are (2, 46), (4, 21), (5,
            12).</t>

            <t><list style="empty">
                <t>At ingress: The fields RND = 45. CML = 0.</t>

                <t>At node-1 (x0): Respective share of POLY-2 is generated
                i.e., (2, 46) because share index of node-1 is 2.</t>

                <t>CML = 0 + ((28 + 46)* 21) mod 53 = 17</t>

                <t>At node-2 (x1): Respective share of POLY-2 is generated
                i.e., (4, 21) because share index of node-2 is 4.</t>

                <t>CML = 17 + ((17 + 21)*48) mod 53 = 17 + 22 = 39</t>

                <t>At node-3 (x2), which is also the verifier: The respective
                share of POLY-2 is generated i.e., (5, 12) because the share
                index of the verifier is 12.</t>

                <t>CML = 39 + ((47 + 12)*38) mod 53 = 39 + 16 = 55 mod 53 =
                2</t>
              </list> The verification using CML is discussed in next
            section.</t>
          </section>

          <section title="Verification">
            <t>As shown in the above example, for final verification, the
            verifier compares:</t>

            <t>VERIFY = (SECRET + RND) mod Prime, with Prime = 53 here</t>

            <t>VERIFY = (RND-1 + RND-2) mod Prime = ( 10 + 45 ) mod 53 = 2</t>

            <t>Since VERIFY = CML the packet is proven to have gone through
            nodes 1, 2, and 3.</t>
          </section>
        </section>

        <section title="Final Version">
          <t>The enhanced version of the protocol is still prone to replay and
          preplay attacks. An attacker could reuse the POT metadata for
          bypassing the verification. So additional measures using packet
          integrity checks (HMAC) and sequence numbers (SEQ_NO) are discussed
          later "Security Considerations" section.</t>
        </section>
      </section>

      <section title="Operational Aspects">
        <t>To operationalize this scheme, a central controller is used to
        generate the necessary polynomials, the secret share per node, the
        prime number, etc. and distributing the data to the nodes
        participating in proof of transit. The identified node that performs
        the verification is provided with the verification key. The
        information provided from the Controller to each of the nodes
        participating in proof of transit is referred to as a proof of transit
        profile (POT-profile). Also note that the set of nodes for which the
        transit has to be proven are typically associated to a different trust
        domain than the verifier. Note that building the trust relationship
        between the Controller and the nodes is outside the scope of this
        document. Techniques such as those described in <xref
        target="I-D.ietf-anima-autonomic-control-plane"></xref> might be
        applied.</t>

        <t>To optimize the overall data amount of exchanged and the processing
        at the nodes the following optimizations are performed:<list
            style="numbers">
            <t>The points (x, y) for each of the nodes on the public and
            private polynomials are picked such that the x component of the
            points match. This lends to the LPC values which are used to
            calculate the cumulative value CML to be constant. Note that the
            LPC are only depending on the x components. They can be computed
            at the controller and communicated to the nodes. Otherwise, one
            would need to distributed the x components to all the nodes.</t>

            <t>A pre-evaluated portion of the public polynomial for each of
            the nodes is calculated and added to the POT-profile. Without this
            all the coefficients of the public polynomial had to be added to
            the POT profile and each node had to evaluate them. As stated
            before, the public portion is only the constant coefficient RND
            value, the pre-evaluated portion for each node should be kept
            secret as well.</t>

            <t>To provide flexibility on the size of the cumulative and random
            numbers carried in the POT data a field to indicate this is shared
            and interpreted at the nodes.</t>
          </list></t>
      </section>

      <section anchor="opot" title="Ordered POT (OPOT)">
        <t>In certain scenarios preserving the order of the nodes traversed by
        the packet may be needed. Two alternatives, one based on &ldquo;nested
        encryption&rdquo;, and another based on &ldquo;symmetric masking
        between nodes&rdquo; are described here for preserving the order</t>

        <section title="Nested Encryption">
          <t><list style="numbers">
              <t>The controller provisions all the nodes with their respective
              secret keys.</t>

              <t>The controller provisions the verifier with all the secret
              keys of the nodes.</t>

              <t>For each packet, the ingress node generates a random number
              RND and encrypts it with its secret key to generate CML
              value</t>

              <t>Each subsequent node on the path encrypts CML with their
              respective secret key and passes it along</t>

              <t>The verifier is also provisioned with the expected sequence
              of nodes in order to verify the order</t>

              <t>The verifier receives the CML, RND values, re-encrypts the
              RND with keys in the same order as expected sequence to
              verify.</t>
            </list></t>

          <t>With this nested encryption approach it is possible to retain the
          order in which the nodes are traversed, at the cost of:</t>

          <t><list style="numbers">
              <t>Standard AES encryption would need 128 bits of RND, CML. This
              results in a 256 bits of additional overhead is added per
              packet</t>

              <t>In hardware platforms that do not support native encryption
              capabilities like (AES-NI). This approach would have
              considerable impact on the computational latency</t>
            </list></t>
        </section>

        <section anchor="mask-opot" title="Symmetric Masking Between Nodes">
          <t><list style="numbers">
              <t>The controller provisions all the nodes with (or asks them to
              agree on) a couple of secrets, that we will refer as masks, one
              for the connection from the upstream node(s), another for the
              connection to the downstream node(s). For obvious reasons, the
              ingress and egress (verifier) nodes only receive one, for
              downstream and upstream, respectively.</t>

              <t>Any two contiguous nodes in the OPOT stream share the mask
              for the connection between them, in the shape of symmetric keys.
              Masks can be refreshed as per-policy, defined at each hop or
              globally by the controller.</t>

              <t>Each mask has the same size in bits as the length assigned to
              CML plus RND, as described in the above sections.</t>

              <t>Whenever a packet is received at an intermediate node, the
              CML+RND sequence is deciphered (by XORing, though other
              ciphering schemas MAY be possible) with the upstream mask before
              applying the procedures described in <xref
              target="enhanced-version"></xref>.</t>

              <t>Once the new values of CML+RND are produced, they are
              ciphered (by XORing, though other ciphering schemas MAY be
              possible) with the downstream mask before transmitting the
              packet to the next node downstream.</t>

              <t>The ingress node only applies step 5 above, while the
              verifier only applies step 4 before running the verification
              procedure.</t>
            </list></t>

          <t>The described process allows the verifier to check if the packet
          has followed the correct order while traversing the path. In
          particular, the reconstruction process will fail if the order is not
          respected, as the deciphering process will produce invalid CML and
          RND values, and the interpolation (secret reconstruction) will
          finally generate a wrong verification value.</t>

          <t>This procedure does not impose a high computational burden, does
          not require additional packet overhead, can be deployed on chains of
          any length, does not require any node to be aware of any additional
          information than the upstream and downstream masks, and can be
          integrated with the other operational mechanisms applied by the
          controller to distribute shares and other secret material.</t>
        </section>
      </section>
    </section>

    <section anchor="metadata-for-pot"
             title="Sizing the Data for Proof of Transit">
      <t>Proof of transit requires transport of two data fields in every
      packet that should be verified:</t>

      <t><list style="numbers">
          <t>RND: Random number (the constant coefficient of public
          polynomial)</t>

          <t>CML: Cumulative</t>
        </list></t>

      <t>The size of the data fields determines how often a new set of
      polynomials would need to be created. At maximum, the largest RND number
      that can be represented with a given number of bits determines the
      number of unique polynomials POLY-2 that can be created. The table below
      shows the maximum interval for how long a single set of polynomials
      could last for a variety of bit rates and RND sizes: When choosing 64
      bits for RND and CML data fields, the time between a renewal of secrets
      could be as long as 3,100 years, even when running at 100 Gbps.</t>

      <texttable anchor="precision" title="Proof of transit data sizing">
        <ttcol align="center">Transfer rate</ttcol>

        <ttcol align="center">Secret/RND size</ttcol>

        <ttcol align="center">Max # of packets</ttcol>

        <ttcol align="center">Time RND lasts</ttcol>

        <c>1 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 310,000 years</c>

        <c>10 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 31,000 years</c>

        <c>100 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 3,100 years</c>

        <c>1 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>2,200 seconds</c>

        <c>10 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>220 seconds</c>

        <c>100 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>22 seconds</c>

        <postamble>Table assumes 64 octet packets</postamble>
      </texttable>

      <t>If the symmetric masking method for ordered POT is used (<xref
      target="mask-opot"></xref>), the masks used between nodes adjacent in
      the path MUST have a length equal to the sum of the ones of RND and
      CML.</t>
    </section>

    <section title="Node Configuration">
      <t>A POT system consists of a number of nodes that participate in POT
      and a Controller, which serves as a control and configuration entity.
      The Controller is to create the required parameters (polynomials, prime
      number, etc.) and communicate those to the nodes. The sum of all
      parameters for a specific node is referred to as "POT-profile". This
      document does not define a specific protocol to be used between
      Controller and nodes. It only defines the procedures and the associated
      YANG data model.</t>

      <section title="Procedure">
        <t>The Controller creates new POT-profiles at a constant rate and
        communicates the POT-profile to the nodes. The controller labels a
        POT-profile &ldquo;even&rdquo; or &ldquo;odd&rdquo; and the Controller
        cycles between &ldquo;even&rdquo; and &ldquo;odd&rdquo; labeled
        profiles. The rate at which the POT-profiles are communicated to the
        nodes is configurable and is more frequent than the speed at which a
        POT-profile is "used up" (see table above). Once the POT-profile has
        been successfully communicated to all nodes (e.g., all NETCONF
        transactions completed, in case NETCONF is used as a protocol), the
        controller sends an &ldquo;enable POT-profile&rdquo; request to the
        ingress node.</t>

        <t>All nodes maintain two POT-profiles (an even and an odd
        POT-profile): One POT-profile is currently active and in use; one
        profile is standby and about to get used. A flag in the packet is
        indicating whether the odd or even POT-profile is to be used by a
        node. This is to ensure that during profile change the service is not
        disrupted. If the &ldquo;odd&rdquo; profile is active, the Controller
        can communicate the &ldquo;even&rdquo; profile to all nodes. Only if
        all the nodes have received the POT-profile, the Controller will tell
        the ingress node to switch to the &ldquo;even&rdquo; profile. Given
        that the indicator travels within the packet, all nodes will switch to
        the &ldquo;even&rdquo; profile. The &ldquo;even&rdquo; profile gets
        active on all nodes and nodes are ready to receive a new
        &ldquo;odd&rdquo; profile.</t>

        <t>Unless the ingress node receives a request to switch profiles,
        it&rsquo;ll continue to use the active profile. If a profile is
        &ldquo;used up&rdquo; the ingress node will recycle the active profile
        and start over (this could give rise to replay attacks in theory
        &ndash; but with 2^32 or 2^64 packets this isn&rsquo;t really likely
        in reality).</t>
      </section>

      <section title="YANG Model">
        <t>This section defines that YANG data model for the information
        exchange between the Controller and the nodes.</t>

        <!-- 
     We need to add the leaves for defining the upstream and downstream masks
     in symmetric OPOT, and maybe some flag to activate OPOT (though it could be 
     implicit by means of the masks)
-->

        <t><figure>
            <artwork><![CDATA[<CODE BEGINS> file "ietf-pot-profile@2016-06-15.yang"
module ietf-pot-profile {

  yang-version 1;

  namespace "urn:ietf:params:xml:ns:yang:ietf-pot-profile";

  prefix ietf-pot-profile;

  organization "IETF xxx Working Group";  

  contact "";

  description "This module contains a collection of YANG
               definitions for proof of transit configuration
               parameters. The model is meant for proof of
               transit and is targeted for communicating the
               POT-profile between a controller and nodes
               participating in proof of transit.";

  revision 2016-06-15 {
    description
      "Initial revision.";
    reference
      "";
  }

  typedef profile-index-range {
    type int32 {
      range "0 .. 1";
    }
    description
      "Range used for the profile index. Currently restricted to
       0 or 1 to identify the odd or even profiles.";
  }


  grouping pot-profile {
    description "A grouping for proof of transit profiles.";
    list pot-profile-list {
      key "pot-profile-index";
      ordered-by user;
      description "A set of pot profiles.";

      leaf pot-profile-index {
        type profile-index-range;
        mandatory true;
        description
          "Proof of transit profile index.";
      }

      leaf prime-number {
        type uint64;
        mandatory true;
        description
          "Prime number used for module math computation";
      }

      leaf secret-share {
        type uint64;
        mandatory true;
        description
          "Share of the secret of polynomial 1 used in computation";
      }

      leaf public-polynomial {
        type uint64;
        mandatory true;
        description
          "Pre evaluated Public polynomial";
      }

      leaf lpc {
        type uint64;
        mandatory true;
        description
          "Lagrange Polynomial Coefficient";
      }

      leaf validator {
        type boolean;
        default "false";
        description
          "True if the node is a verifier node";
      }

      leaf validator-key {
        type uint64;
        description
          "Secret key for validating the path, constant of poly 1";
      }

      leaf bitmask {
        type uint64;
        default 4294967295;
        description
          "Number of bits as mask used in controlling the size of the
           random value generation. 32-bits of mask is default.";
      }
    }
  }

  container pot-profiles {
    description "A group of proof of transit profiles.";

    list pot-profile-set {
      key "pot-profile-name";
      ordered-by user;
      description
        "Set of proof of transit profiles that group parameters
         required to classify and compute proof of transit
         metadata at a node";

      leaf pot-profile-name {
        type string;
        mandatory true;
        description
          "Unique identifier for each proof of transit profile";
      }

      leaf active-profile-index {
        type profile-index-range;
        description
          "Proof of transit profile index that is currently active.
           Will be set in the first hop of the path or chain.
           Other nodes will not use this field.";
      }

      uses pot-profile;
    }
  /*** Container: end ***/
  }
/*** module: end ***/
}
<CODE ENDS>
]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>IANA considerations will be added in a future version of this
      document.</t>
    </section>

    <section title="Manageability Considerations">
      <t>Manageability considerations will be addressed &iacute;n a later
      version of this document.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Different security requirements achieved by the solution approach are
      discussed here.</t>

      <section title="Proof of Transit">
        <t>Proof of correctness and security of the solution approach is per
        Shamir&rsquo;s Secret Sharing Scheme <xref target="SSS"></xref>.
        Cryptographically speaking it achieves information-theoretic security
        i.e., it cannot be broken by an attacker even with unlimited computing
        power. As long as the below conditions are met it is impossible for an
        attacker to bypass one or multiple nodes without getting caught.</t>

        <t><list style="symbols">
            <t>If there are k+1 nodes in the path, the polynomials (POLY-1,
            POLY-2) should be of degree k. Also k+1 points of POLY-1 are
            chosen and assigned to each node respectively. The verifier can
            re-construct the k degree polynomial (POLY-3) only when all the
            points are correctly retrieved.</t>

            <t>Precisely three values are kept secret by individual nodes.
            Share of SECRET (i.e. points on POLY-1), Share of POLY-2, LPC, P.
            Note that only constant coefficient, RND, of POLY-2 is public. x
            values and non-constant coefficient of POLY-2 are secret</t>
          </list> An attacker bypassing a few nodes will miss adding a
        respective point on POLY-1 to corresponding point on POLY-2 , thus the
        verifier cannot construct POLY-3 for cross verification.</t>

        <t>Also it is highly recommended that different polynomials should be
        used as POLY-1 across different paths, traffic profiles or service
        chains.</t>

        <t>If symmetric masking is used to assure OPOT (<xref
        target="mask-opot"></xref>), the nodes need to keep two additional
        secrets: the upstream and upstream masks, that have to be managed
        under the same conditions as the secrets mentioned above. And it is
        equally recommended to employ a different set of mask pairs across
        different paths, traffic profiles or service chains.</t>
      </section>

      <section title="Cryptanalysis">
        <t>A passive attacker could try to harvest the POT data (i.e., CML,
        RND values) in order to determine the configured secrets. Subsequently
        two types of differential analysis for guessing the secrets could be
        done. <list style="symbols">
            <t>Inter-Node: A passive attacker observing CML values across
            nodes (i.e., as the packets entering and leaving), cannot perform
            differential analysis to construct the points on POLY-1. This is
            because at each point there are four unknowns (i.e. Share(POLY-1),
            Share(Poly-2) LPC and prime number P) and three known values (i.e.
            RND, CML-before, CML-after). The application of symmetric masking
            for OPOT makes inter-node analysis less feasible.</t>

            <t>Inter-Packets: A passive attacker could observe CML values
            across packets (i.e., values of PKT-1 and subsequent PKT-2), in
            order to predict the secrets. Differential analysis across packets
            could be mitigated using a good PRNG for generating RND. Note that
            if constant coefficient is a sequence number than CML values
            become quite predictable and the scheme would be broken. If
            symmetric masking is used for OPOT, inter-packet analysis could be
            applied to guess mask values, what requires a proper refresh rate
            for masks, at least as high as the one used for LPCs.</t>
          </list></t>
      </section>

      <section title="Anti-Replay">
        <t>A passive attacker could reuse a set of older RND and the
        intermediate CML values to bypass certain nodes in later packets. Such
        attacks could be avoided by carefully choosing POLY-2 as a (SEQ_NO +
        RND). For example, if 64 bits are being used for POLY-2 then first 16
        bits could be a sequence number SEQ_NO and next 48 bits could be a
        random number.</t>

        <t>Subsequently, the verifier could use the SEQ_NO bits to run classic
        anti-replay techniques like sliding window used in IPSEC. The verifier
        could buffer up to 2^16 packets as a sliding window. Packets arriving
        with a higher SEQ_NO than current buffer could be flagged legitimate.
        Packets arriving with a lower SEQ_NO than current buffer could be
        flagged as suspicious.</t>

        <t>For all practical purposes in the rest of the document RND means
        SEQ_NO + RND to keep it simple.</t>

        <t>The solution discussed in this memo does not currently mitigate
        replay attacks. An anti-replay mechanism may be included in future
        versions of the solution.</t>
      </section>

      <section title="Anti-Preplay">
        <t>An active attacker could try to perform a man-in-the-middle (MITM)
        attack by extracting the POT of PKT-1 and using it in PKT-2.
        Subsequently attacker drops the PKT-1 in order to avoid duplicate POT
        values reaching the verifier. If the PKT-1 reaches the verifier, then
        this attack is same as Replay attacks discussed before.</t>

        <t>Preplay attacks are possible since the POT metadata is not
        dependent on the packet fields. Below steps are recommended for
        remediation:<list style="symbols">
            <t>Ingress node and Verifier are configured with common pre shared
            key</t>

            <t>Ingress node generates a Message Authentication Code (MAC) from
            packet fields using standard HMAC algorithm.</t>

            <t>The left most bits of the output are truncated to desired
            length to generate RND. It is recommended to use a minimum of 32
            bits.</t>

            <t>The verifier regenerates the HMAC from the packet fields and
            compares with RND. To ensure the POT data is in fact that of the
            packet.</t>
          </list></t>

        <t>If an HMAC is used, an active attacker lacks the knowledge of the
        pre-shared key, and thus cannot launch preplay attacks.</t>

        <t>The solution discussed in this memo does not currently mitigate
        prereplay attacks. A mitigation mechanism may be included in future
        versions of the solution.</t>
      </section>

      <section title="Anti-Tampering">
        <t>An active attacker could not insert any arbitrary value for CML.
        This would subsequently fail the reconstruction of the POLY-3. Also an
        attacker could not update the CML with a previously observed value.
        This could subsequently be detected by using timestamps within the RND
        value as discussed above.</t>
      </section>

      <section title="Recycling">
        <t>The solution approach is flexible for recycling long term secrets
        like POLY-1. All the nodes could be periodically updated with shares
        of new SECRET as best practice. The table above could be consulted for
        refresh cycles (see <xref target="metadata-for-pot"></xref>).</t>

        <t>If symmetric masking is used for OPOT (<xref
        target="mask-opot"></xref>), mask values must be periodically updated
        as well, at least as frequently as the other secrets are.</t>
      </section>

      <section title="Redundant Nodes and Failover">
        <t>A "node" or "service" in terms of POT can be implemented by one or
        multiple physical entities. In case of multiple physical entities
        (e.g., for load-balancing, or business continuity situations -
        consider for example a set of firewalls), all physical entities which
        are implementing the same POT node are given that same share of the
        secret. This makes multiple physical entities represent the same POT
        node from an algorithm perspective.</t>
      </section>

      <section title="Controller Operation">
        <t>The Controller needs to be secured given that it creates and holds
        the secrets, as need to be the nodes. The communication between
        Controller and the nodes also needs to be secured. As secure
        communication protocol such as for example NETCONF over SSH should be
        chosen for Controller to node communication.</t>

        <t>The Controller only interacts with the nodes during the initial
        configuration and thereafter at regular intervals at which the
        operator chooses to switch to a new set of secrets. In case 64 bits
        are used for the data fields "CML" and "RND" which are carried within
        the data packet, the regular intervals are expected to be quite long
        (e.g., at 100 Gbps, a profile would only be used up after 3100 years)
        - see <xref target="metadata-for-pot"></xref> above, thus even a
        "headless" operation without a Controller can be considered feasible.
        In such a case, the Controller would only be used for the initial
        configuration of the POT-profiles.</t>

        <t>If OPOT (<xref target="mask-opot"></xref>) is applied using
        symmetric masking, the Controller will be required to perform a a
        periodic refresh of the mask pairs. The use of OPOT SHOULD be
        configurable as part of the required level of assurance through the
        Controller management interface.</t>
      </section>

      <section title="Verification Scope">
        <t>The POT solution defined in this document verifies that a
        data-packet traversed or transited a specific set of nodes. From an
        algorithm perspective, a "node" is an abstract entity. It could be
        represented by one or multiple physical or virtual network devices, or
        is could be a component within a networking device or system. The
        latter would be the case if a forwarding path within a device would
        need to be securely verified.</t>

        <section title="Node Ordering">
          <t>POT using Shamir's secret sharing scheme as discussed in this
          document provides for a means to verify that a set of nodes has been
          visited by a data packet. It does not verify the order in which the
          data packet visited the nodes.</t>

          <t>In case the order in which a data packet traversed a particular
          set of nodes needs to be verified as well, the alternate schemes
          related to OPOT (<xref target="opot"></xref>) have to be considered.
          Since these schemes introduce at least additional control
          requirements, the selection of order verification SHOULD be
          configurable the Controller management interface.</t>
        </section>

        <section title="Stealth Nodes">
          <t>The POT approach discussed in this document is to prove that a
          data packet traversed a specific set of "nodes". This set could be
          all nodes within a path, but could also be a subset of nodes in a
          path. Consequently, the POT approach isn't suited to detect whether
          "stealth" nodes which do not participate in proof-of-transit have
          been inserted into a path.</t>
        </section>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
      Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
      Nadahalli, Erik Nordmark, and Andrew Yourtchenko for the comments and
      advice.</t>
    </section>
  </middle>

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;
      
      &RFC7665;

      <reference anchor="SSS"
                 target="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">
        <front>
          <title>Shamir's Secret Sharing</title>

          <author fullname="Wikipedia"></author>

          <date />
        </front>
      </reference>
    </references>

    <references title="Informative References">
      &I-D.draft-ietf-anima-autonomic-control-plane;
    </references>
  </back>
</rfc>
