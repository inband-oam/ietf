<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC7665 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7665.xml">
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6830 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6830.xml">
<!ENTITY RFC6833 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6833.xml">
<!ENTITY RFC2460 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC791 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC6564 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.6564.xml">
<!ENTITY I-D.ietf-spring-segment-routing SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-spring-segment-routing.xml">
<!ENTITY I-D.draft-ietf-anima-autonomic-control-plane SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-anima-autonomic-control-plane-03.xml">
<!ENTITY I-D.previdi-isis-segment-routing-extensions SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.previdi-isis-segment-routing-extensions.xml">
<!ENTITY I-D.ietf-ippm-6man-pdm-option SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-ippm-6man-pdm-option.xml">
<!ENTITY I-D.gont-v6ops-ipv6-ehs-in-real-world SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.gont-v6ops-ipv6-ehs-in-real-world.xml">
<!ENTITY I-D.brockners-lisp-sr SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.brockners-lisp-sr.xml">
<!ENTITY I-D.hildebrand-spud-prototype SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY I-D.ietf-sfc-nsh SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-sfc-nsh.xml">
<!ENTITY I-D.ietf-6man-segment-routing-header SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-6man-segment-routing-header.xml">
<!ENTITY I-D.ietf-nvo3-vxlan-gpe SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-nvo3-vxlan-gpe.xml">
<!ENTITY I-D.lapukhov-dataplane-probe SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.lapukhov-dataplane-probe.xml">
<!ENTITY I-D.SPUD SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY AFI SYSTEM "http://www.iana.org/assignments/address-family-numbers/address-family-numbers.xml">
]>
<!-- Comments received
Tal Mizrahi [mailto:talmi@marvell.com]
To summarize my take on this thread:
The proposed mechanism has two significant vulnerabilities that (in my understanding) are currently not addressed:
1.       A man-in-the-middle can replace the POT of packet A with the POT of packet B.
2.       It is possible to replay POTs within a certain time window, whose length is determined by the timestamp resolution.
 
-->
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="exp" docName="draft-brockners-proof-of-transit-01"
     ipr="trust200902">
  <!-- ipr="full3978"-->

  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="Proof of Transit">Proof of Transit</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Frank Brockners" initials="F." surname="Brockners">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Hansaallee 249, 3rd Floor</street>

          <!-- Reorder these if your country does things differently -->

          <city>DUESSELDORF</city>

          <region>NORDRHEIN-WESTFALEN</region>

          <code>40549</code>

          <country>Germany</country>
        </postal>

        <email>fbrockne@cisco.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>Bangalore, KARNATAKA 560 087</city>

          <country>India</country>
        </postal>

        <email>shwethab@cisco.com</email>
      </address>
    </author>

    <author fullname="Sashank Dara" initials="S." surname="Dara">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>BANGALORE</city>

          <region>Bangalore, KARNATAKA 560 087</region>

          <code/>

          <country>INDIA</country>
        </postal>

        <phone/>

        <facsimile/>

        <email>sadara@cisco.com</email>

        <uri/>
      </address>
    </author>

    <author fullname="Carlos Pignataro" initials="C." surname="Pignataro">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>7200-11 Kit Creek Road</street>

          <city>Research Triangle Park</city>

          <region>NC</region>

          <code>27709</code>

          <country>United States</country>
        </postal>

        <email>cpignata@cisco.com</email>
      </address>
    </author>

    <author fullname="John Leddy" initials="J." surname="Leddy">
      <organization abbrev="Comcast">Comcast</organization>

      <address>
        <email>John_Leddy@cable.comcast.com</email>
      </address>
    </author>

    <author fullname="Stephen Youell" initials="S." surname="Youell">
      <organization abbrev="JMPC">JP Morgan Chase</organization>

      <address>
        <postal>
          <street>25 Bank Street</street>

          <city>London</city>

          <code>E14 5JP</code>

          <country>United Kingdom</country>
        </postal>

        <email>stephen.youell@jpmorgan.com</email>
      </address>
    </author>

    <date day="18" month="July" year="2016"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- OAM data Declarations -->

    <area>ops</area>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>Telemetry, Tracing, Proof of Transit</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>Several technologies such as traffic engineering, service function
      chaining, or policy based routing, are used to steer traffic through a
      specific, user-defined path. This document defines mechanisms to
      securely prove that traffic transited the defined path. The mechanisms
      allow to securely verify whether all packets traversed all those nodes
      of a given path that they are supposed to visit.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Several deployments use traffic engineering, policy routing, segment
      routing or Service Function Chaining (SFC) <xref target="RFC7665"/> to
      steer packets through a specific set of nodes. In certain cases
      regulatory obligations or a compliance policy require operators to prove
      that all packets that are supposed to follow a specific path are indeed
      being forwarded across and exact set of pre-determined nodes.</t>

      <t>If a packet flow is supposed to go through a series of service
      functions or network nodes, it has to be proven that indeed all packets
      of the flow followed the path or service chain or collection of nodes
      specified by the policy. In case some packets of a flow weren't
      appropriately processed, a verification device should determine the
      policy violation and take corresponding actions corresponding to the
      policy (e.g., drop or redirect the packet, send an alert etc.). In
      today's deployments, the proof that a packet traversed a particular path
      or service chain is typically delivered in an indirect way: Service
      appliances and network forwarding are in different trust domains.
      Physical hand-off-points are defined between these trust domains (i.e.
      physical interfaces). Or in other terms, in the "network forwarding
      domain" things are wired up in a way that traffic is delivered to the
      ingress interface of a service appliance and received back from an
      egress interface of a service appliance. This "wiring" is verified and
      then trusted upon. The evolution to Network Function Virtualization
      (NFV) and modern service chaining concepts (using technologies such as
      LISP, NSH, Segment Routing (SR), etc.) blurs the line between the
      different trust domains, because the hand-off-points are no longer
      clearly defined physical interfaces, but are virtual interfaces. As a
      consequence, different trust layers should not to be mixed in the same
      device. For an NFV scenario a different type of proof is required.
      Offering a proof that a packet indeed traversed a specific set of
      service functions or nodes allows operators to evolve from the above
      described indirect methods of proving that packets visit a predetermined
      set of nodes.</t>

      <t>The solution approach presented in this document is based on a small
      portion of operational data added to every packet. This "in-band"
      operational data is also referred to as "proof of transit data", or POT
      data. The POT data is updated at every required node and is used to
      verify whether a packet traversed all required nodes. A particular set
      of nodes "to be verified" is either described by a set of secret keys,
      or a set of shares of a single secret. Nodes on the path retrieve their
      individual keys or shares of a key (using for e.g., Shamir's Secret
      Sharing scheme) from a central controller. The complete key set is only
      known to the controller and a verifier node, which is typically the
      ultimate node on a path that performs verification. Each node in the
      path uses its secret or share of the secret to update the POT data of
      the packets as the packets pass through the node. When the verifier
      receives a packet, it uses its key(s) along with data found in the
      packet to validate whether the packet traversed the path correctly.</t>
    </section>

    <section anchor="Conventions" title="Conventions">
      <!--
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>
-->

      <t>Abbreviations used in this document:</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="MTU:">Maximum Transmit Unit</t>

          <t hangText="SR:">Segment Routing</t>

          <t hangText="NSH:">Network Service Header</t>

          <t hangText="SFC:">Service Function Chain</t>

          <t hangText="POT:">Proof of Transit</t>

          <t hangText="POT-profile:">Proof of Transit Profile that has the
          necessary data for nodes to participate in proof of transit</t>
        </list></t>
    </section>

    <section title="Proof of Transit">
      <t>This section discusses methods and algorithms to provide for a "proof
      of transit" for packets traversing a specific path. A path which is to
      be verified consists of a set of nodes. Transit of the data packets
      through those nodes is to be proven. Besides the nodes, the setup also
      includes a Controller that creates secrets and secrets shares and
      configures the nodes for POT operations.</t>

      <t>The methods how traffic is identified and associated to a specific
      path is outside the scope of this document. Identification could be done
      using a filter (e.g., 5-tupel classifier), or an identifier which is
      already present in the packet (e.g., path or service identifier,
      flow-label, etc.).</t>

      <t>The solution approach is detailed in two steps. Initially the concept
      of the approach is explained. This concept is then further refined to
      make it operationally feasible.</t>

      <section title="Basic Idea">
        <t>The method relies on adding POT data to all packets that traverse a
        path. The added POT data allows a verifying node (egress node) to
        check whether a packet traversed the identified set of nodes on a path
        correctly or not. Security mechanisms are natively built into the
        generation of the POT data to protect against misuse (i.e.
        configuration mistakes, malicious administrators playing tricks with
        routing, capturing, spoofing and replaying packets). The mechanism for
        POT leverages "Shamir's secret sharing scheme" <xref
        target="SSS"/>.</t>

        <t>Shamir's secret sharing base idea: A polynomial (represented by its
        co-efficients) is chosen as a secret by the controller. A polynomial
        represents a curve. A set of well defined points on the curve are
        needed to construct the polynomial. Each point of the polynomial is
        called &ldquo;share&rdquo; of the secret. A single secret is
        associated with a particular set of nodes, which typically represent
        the path, to be verified. Shares of the single secret (i.e., points on
        the curve) are securely distributed from a Controller to the network
        nodes. Nodes use their respective share to update a cumulative value
        in the POT data of each packet. Only a verifying node has access to
        the complete secret. The verifying node validates the correctness of
        the received POT data by reconstructing the curve.</t>

        <t>The polynomial cannot be constructed if any of the points are
        missed or tampered. Per Shamir's Secret Sharing Scheme, any lesser
        points means one or more nodes are missed. Details of the precise
        configuration needed for achieving security are discussed further
        below.</t>

        <t>While applicable in theory, a vanilla approach based on Shamir's
        secret sharing could be easily attacked. If the same polynomial is
        reused for every packet for a path a passive attacker could reuse the
        value. As a consequence, one could consider creating a different
        polynomial per packet. Such an approach would be operationally
        complex. It would be complex to configure and recycle so many curves
        and their respective points for each node. Rather than using a single
        polynomial, two polynomials are used for the solution approach: A
        secret polynomial which is kept constant, and a per-packet polynomial
        which is public. Operations are performed on the sum of those two
        polynomials - creating a third polynomial which is secret and per
        packet.</t>
      </section>

      <section title="Solution Approach">
        <t>Solution approach: The overall algorithm uses two polynomials:
        POLY-1 and POLY-2. POLY-1 is secret and constant. Each node gets a
        point on POLY-1 at setup-time and keeps it secret. POLY-2 is public,
        random and per packet. Each node generates a point on POLY-2 each time
        a packet crosses it. Each node then calculates (point on POLY-1 +
        point on POLY-2) to get a (point on POLY-3) and passes it to verifier
        by adding it to each packet. The verifier constructs POLY-3 from the
        points given by all the nodes and cross checks whether POLY-3 = POLY-1
        + POLY-2. Only the verifier knows POLY-1. The solution leverages
        finite field arithmetic in a field of size &ldquo;prime
        number&rdquo;.</t>

        <t>Detailed algorithms are discussed next. A simple example is
        discussed in <xref target="toy-example"/>.</t>

        <section title="Setup">
          <t>A controller generates a first polynomial (POLY-1) of degree k
          and k+1 points on the polynomial. The constant coefficient of POLY-1
          is considered the SECRET. The non-constant coefficients are used to
          generate the Lagrange Polynomial Constants (LPC). Each of the k
          nodes (including verifier) are assigned a point on the polynomial
          i.e., shares of the SECRET. The verifier is configured with the
          SECRET. The Controller also generates coefficients (except the
          constant coefficient, called "RND", which is changed on a per packet
          basis) of a second polynomial POLY-2 of the same degree. Each node
          is configured with the LPC of POLY-2. Note that POLY-2 is
          public.</t>
        </section>

        <section title="In Transit">
          <t>For each packet, the source node generates a random number (RND).
          It is considered as the constant coefficient for POLY-2. A
          cumulative value (CML) is initialized to 0. Both RND, CML are
          carried as within the packet POT data. As the packet visits each
          node, the RND is retrieved from the packet and the respective share
          of POLY-2 is calculated. Each node calculates
          (Share(POLY-1)+Share(POLY-2)) and CML is updated with this sum. This
          step is performed by each node until the packet completes the path.
          The verifier also performs the step with its respective share.</t>
        </section>

        <section title="Verification">
          <t>The verifier cross checks whether CML = SECRET + RND. If this
          matches then the packet traversed the specified set of nodes in the
          path. This is due to the additive homomorphic property of Shamir's
          Secret Sharing scheme.</t>
        </section>
      </section>

      <section anchor="toy-example" title="Example for Illustration">
        <t>This section shows a simple example to illustrate step by step the
        approach described above.</t>

        <section title="Basic Version">
          <t>Assumption: We like to verify that packets pass through 3 nodes.
          Consequently we need a polynomial of degree 2.</t>

          <t>Choices: Prime = 53. POLY-1(x) = (3x^2 + 3x + 10) mod 53. The
          secret to be re-constructed is the constant coefficient of POLY-1,
          i.e., SECRET=10. It is important to note that all operations are
          done over a finite field (i.e., modulo prime).</t>

          <section title="Secret Shares">
            <t>The shares of the secret are the points on POLY-1 chosen for
            the 3 nodes. Here we use x0=2, x1=4, x2=5.</t>

            <t><list style="empty">
                <t>POLY-1(2) = 28 =&gt; (x0,y0) = (2,28)</t>

                <t>POLY-1(4) = 17 =&gt; (x1,y1) = (4,17)</t>

                <t>POLY-1(5) = 47 =&gt; (x2,y2) = (5,47)</t>
              </list></t>

            <t>The three points above are the points on the curve which are
            considered the shares of the secret. They are assigned to three
            nodes respectively and are kept secret.</t>
          </section>

          <section title="Lagrange Polynomials">
            <t>Lagrange basis polynomials (or Lagrange polynomials) are used
            for polynomial interpolation. For a given set of points on the
            curve Lagrange polynomials (as defined below) are used to
            reconstruct the curve and thus reconstruct the complete
            secret.</t>

            <t><list style="empty">
                <t>l0(x) = (((x-x1)/(x0-x1))*((x-x2)/x0-x2))) mod 53 = <vspace
                blankLines="0"/>(((x-4)/(2-4))*((x-5)/2-5))) mod 53 = <vspace
                blankLines="0"/>(10/3 - 3x/2 + (1/6)x^2) mod 53</t>

                <t>l1(x) = (((x-x0)/(x1-x0))*((x-x2)/x1-x2))) mod 53 = <vspace
                blankLines="0"/>(-5 + 7x/2 - (1/2)x^2) mod 53</t>

                <t>l2(x) = (((x-x0)/(x2-x0))*((x-x1)/x2-x1))) mod 53 = <vspace
                blankLines="0"/>(8/3 - 2 + (1/3)x^2) mod 53</t>
              </list></t>
          </section>

          <section title="LPC Computation">
            <t>Since x0=2, x1=4, x2=5 are chosen points. Given that
            computations are done over a finite arithmetic field ("modulo a
            prime number"), the Lagrange basis polynomial constants (LPC) are
            computed modulo 53. The Lagrange polynomial constant (LPC) would
            be 10/3 , -5 , 8/3.</t>

            <t><list style="empty">
                <t>LPC(x0) = (10/3) mod 53 = 21</t>

                <t>LPC(x1) = (-5) mod 53 = 48</t>

                <t>LPC(x2) = (8/3) mod 53 = 38</t>
              </list>For a general way to compute the modular multiplicative
            inverse, see e.g., the Euclidean algorithm.</t>
          </section>

          <section title="Reconstruction">
            <t>Reconstruction of the polynomial is well defined as</t>

            <t><!-- To ensure equations are on separate line for
				 readability --> POLY1(x) = l0(x)*y0 + l1(x)*y1 + l2(x)*y2.</t>

            <t>Subsequently, the SECRET, which is the constant coefficient of
            POLY1(x) can be computed as below</t>

            <t>SECRET = (y0*LPC(l0)+y1*LPC(l1)+y2*LPC(l2)) mod 53.</t>

            <t>The secret can be easily reconstructed using the y-values and
            the LPC:</t>

            <t>SECRET = (y0*LPC(l0) + y1*LPC(l1) + y2*LPC(l2)) mod 53 = mod
            (28 * 21 + 17 * 48 + 47 * 38) mod 53 = 3190 mod 53 = 10.</t>

            <t>One observes that the secret reconstruction can easily be
            performed cumulatively hop by hop. CML represents the cumulative
            value. It is the POT data in the packet that is updated at each
            hop with the node's respective (yi*LPC(i)), where i is their
            respective value.</t>
          </section>

          <section title="Verification">
            <t>Upon completion of the path, the resulting CML is retrieved by
            the verifier from the packet POT data. Recall that verifier is
            preconfigured with the original SECRET. It is cross checked with
            the CML by the verifier. Subsequent actions based on the
            verification failing or succeeding could be taken as per the
            configured policies.</t>
          </section>
        </section>

        <section title="Enhanced Version">
          <t>As observed previously, the vanilla algorithm that involves a
          single secret polynomial is not secure. We enhance the solution with
          usage of a random second polynomial chosen per packet.</t>

          <section title="Random Polynomial">
            <t>Let the second polynomial POLY-2 be (RND + 7x + 10 x^2). RND is
            a random number and is generated for each packet. Note that POLY-2
            is public and need not be kept secret. The nodes can be
            pre-configured with the non-constant coefficients (for example, 7
            and 10 in this case could be configured through the Controller on
            each node).</t>
          </section>

          <section title="Reconstruction">
            <t>Recall that each node is preconfigured with their respective
            Share(POLY-1). Each node calculates its respective Share(POLY-2)
            using the RND value retrieved from the packet. The CML
            reconstruction is enhanced as below. At every node, CML is updated
            as</t>

            <t>CML = CML+(((Share(POLY-1)+ Share(POLY-2)) * LPC) mod
            Prime.</t>

            <t>Lets observe the packet level transformations in detail. For
            the example packet here, let the value RND be 45. Thus POLY-2
            would be (45 + 7x + 10x^2).</t>

            <t>The shares that could be generated are (2,46), (4,21),
            (5,12).</t>

            <t><list style="empty">
                <t>At source: The fields RND = 45. CML = 0.</t>

                <t>At node-1 (x0): Respective share of POLY-2 is generated i.e
                (2,46) because share index of node-1 is 2.</t>

                <t>CML = 0 + ((28 + 46)* 21) mod 53 = 17.</t>

                <t>At node-2 (x1): Respective share of POLY-2 is generated i.e
                (4,21) because share index of node-2 is 4.</t>

                <t>CML = 17 + ((17 + 21)*48) mod 53 = 17 + 22 = 39.</t>

                <t>At node-3 (x2), which is also the verifier: The respective
                share of POLY-2 is generated i.e (5,12) because the share
                index of the verifier is 12.</t>

                <t>CML = 39 + ((47 + 12)*38) mod 53 = 39 + 16 = 55 mod 53 =
                2</t>
              </list> The verification using CML is discussed in next
            section.</t>
          </section>

          <section title="Verification">
            <t>As shown in the above example, for final verification, the
            verifier compares:</t>

            <t>VERIFY = (SECRET + RND) mod Prime, with Prime = 53 here.</t>

            <t>VERIFY = (RND-1 + RND-2) mod Prime = ( 10 + 45 ) mod 53 =
            2.</t>

            <t>Since VERIFY = CML the packet is proven to have gone through
            nodes 1, 2, and 3.</t>
          </section>
        </section>
      </section>

      <section title="Operational Aspects">
        <t>To operationalize this scheme, a central controller is used to
        generate the necessary polynomials, the secret share per node, the
        prime number, etc. and distributing the data to the nodes
        participating in proof of transit. The identified node that performs
        the verification is provided with the verification key. The
        information provided from the Controller to each of the nodes
        participating in proof of transit is referred to as a proof of transit
        profile (POT-profile). Also note that the set of nodes for which the
        transit has to be proven are typically associated to a different trust
        domain than the verifier. Note that building the trust relationship
        between the Controller and the nodes is outside the scope of this
        document. Techniques such as those described in <xref
        target="I-D.ietf-anima-autonomic-control-plane"/> might be
        applied.</t>

        <t>To optimize the overall data amount of exchanged and the processing
        at the nodes the following optimizations are performed:<list
            style="numbers">
            <t>The points (x,y) for each of the nodes on the public and
            private polynomials are picked such that the x component of the
            points match. This lends to the LPC values which are used to
            calculate the cumulative value CML to be constant. Note that the
            LPC are only depending on the x components. The can be computed at
            the controller and communicated to the nodes. Otherwise, one would
            need to distributed the x components to all the nodes.</t>

            <t>A pre-evaluated portion of the public polynomial for each of
            the nodes is calculated and added to the POT-profile. Without this
            all the coefficients of the public polynomial had to be added to
            the POT profile and each node had to evaluate them.</t>

            <t>To provide flexibility on the size of the cumulative and random
            numbers carried in the POT data a field to indicate this is shared
            and interpreted at the nodes.</t>
          </list></t>
      </section>
    </section>

    <section anchor="metadata-for-pot"
             title="Sizing the Data for Proof of Transit">
      <t>Proof of transit requires transport of two data records in every
      packet that should be verified:</t>

      <t><list style="numbers">
          <t>RND: Random number (the constant coefficient of public
          polynomial)</t>

          <t>CML: Cumulative</t>
        </list></t>

      <t>The size of the data records determines how often a new set of
      polynomials would need to be created. At maximum, the largest RND number
      that can be represented with a given number of bits determines the
      number of unique polynomials POLY-2 that can be created. The table below
      shows the maximum interval for how long a single set of polynomials
      could last for a variety of bit rates and RND sizes: When choosing 64
      bits for RND and CML data records, the time between a renewal of secrets
      could be as long as 3,100 years, even when running at 100 Gbps.</t>

      <texttable anchor="precision" title="Proof of transit data sizing">
        <ttcol align="center">Transfer rate</ttcol>

        <ttcol align="center">Secret/RND size</ttcol>

        <ttcol align="center">Max # of packets</ttcol>

        <ttcol align="center">Time RND lasts</ttcol>

        <c>1 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 310,000 years</c>

        <c>10 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 31,000 years</c>

        <c>100 Gbps</c>

        <c>64</c>

        <c>2^64 = approx. 2*10^19</c>

        <c>approx. 3,100 years</c>

        <c>1 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>2,200 seconds</c>

        <c>10 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>220 seconds</c>

        <c>100 Gbps</c>

        <c>32</c>

        <c>2^32 = approx. 4*10^9</c>

        <c>22 seconds</c>

        <postamble>Table assumes 64 octet packets</postamble>
      </texttable>
    </section>

    <section title="Node Configuration">
      <t>A POT system consists of a number of nodes that participate in POT
      and a Controller, which serves as a control and configuration entity.
      The Controller is to create the required parameters (polynomials, prime
      number, etc.) and communicate those to the nodes. The sum of all
      parameters for a specific node is referred to as "POT-profile". This
      document does not define a specific protocol to be used between
      Controller and nodes. It only defines the procedures and the associated
      YANG data model.</t>

      <section title="Procedure">
        <t>The Controller creates new POT-profiles at a constant rate and
        communicates the POT-profile to the nodes. The controller labels a
        POT-profile &ldquo;even&rdquo; or &ldquo;odd&rdquo; and the Controller
        cycles between &ldquo;even&rdquo; and &ldquo;odd&rdquo; labeled
        profiles. The rate at which the POT-profiles are communicated to the
        nodes is configurable and is more frequent than the speed at which a
        POT-profile is "used up" (see table above). Once the POT-profile has
        been successfully communicated to all nodes (e.g., all Netconf
        transactions completed, in case Netconf is used as a protocol), the
        controller sends an &ldquo;enable POT-profile&rdquo; request to the
        ingress node.</t>

        <t>All nodes maintain two POT-profiles (an even and an odd
        POT-profile): One POT-profile is currently active and in use; one
        profile is standby and about to get used. A flag in the packet is
        indicating whether the odd or even POT-profile is to be used by a
        node. This is to ensure that during profile change the service is not
        disrupted. If the &ldquo;odd&rdquo; profile is active, the Controller
        can communicate the &ldquo;even&rdquo; profile to all nodes. Only if
        all the nodes have received the POT-profile, the Controller will tell
        the ingress node to switch to the &ldquo;even&rdquo; profile. Given
        that the indicator travels within the packet, all nodes will switch to
        the &ldquo;even&rdquo; profile. The &ldquo;even&rdquo; profile gets
        active on all nodes and nodes are ready to receive a new
        &ldquo;odd&rdquo; profile.</t>

        <t>Unless the ingress node receives a request to switch profiles,
        it&rsquo;ll continue to use the active profile. If a profile is
        &ldquo;used up&rdquo; the ingress node will recycle the active profile
        and start over (this could give rise to replay attacks in theory
        &ndash; but with 2^32 or 2^64 packets this isn&rsquo;t really likely
        in reality).</t>
      </section>

      <section title="YANG Model">
        <t>This section defines that YANG data model for the information
        exchange between the Controller and the nodes.</t>

        <t><figure>
            <artwork><![CDATA[module ietf-pot-profile {

  yang-version 1;

  namespace "urn:ietf:params:xml:ns:yang:ietf-pot-profile";

  prefix ietf-pot-profile;

  organization "IETF xxx Working Group";  

  contact "";

  description "This module contains a collection of YANG
               definitions for proof of transit configuration
               parameters. The model is meant for proof of
               transit and is targeted for communicating the
               POT-profile between a controller and nodes
               participating in proof of transit.";

  revision 2016-06-15 {
    description
      "Initial revision.";
    reference
      "";
  }

  typedef profile-index-range {
    type int32 {
      range "0 .. 1";
    }
    description
      "Range used for the profile index. Currently restricted to
       0 or 1 to identify the odd or even profiles.";
  }


  grouping pot-profile {
    description "A grouping for proof of transit profiles.";
    list pot-profile-list {
      key "pot-profile-index";
      ordered-by user;
      description "A set of pot profiles.";

      leaf pot-profile-index {
        type profile-index-range;
        mandatory true;
        description
          "Proof of transit profile index.";
      }

      leaf prime-number {
        type uint64;
        mandatory true;
        description
          "Prime number used for module math computation";
      }

      leaf secret-share {
        type uint64;
        mandatory true;
        description
          "Share of the secret of polynomial 1 used in computation";
      }

      leaf public-polynomial {
        type uint64;
        mandatory true;
        description
          "Pre evaluated Public polynomial";
      }

      leaf lpc {
        type uint64;
        mandatory true;
        description
          "Lagrange Polynomial Coefficient";
      }

      leaf validator {
        type boolean;
        default "false";
        description
          "True if the node is a verifier node";
      }

      leaf validator-key {
        type uint64;
        description
          "Secret key for validating the path, constant of poly 1";
      }

      leaf bitmask {
        type uint64;
        default 4294967295;
        description
          "Number of bits as mask used in controlling the size of the
           random value generation. 32-bits of mask is default.";
      }
    }
  }

  container pot-profiles {
    description "A group of proof of transit profiles.";

    list pot-profile-set {
      key "pot-profile-name";
      ordered-by user;
      description
        "Set of proof of transit profiles that group parameters
         required to classify and compute proof of transit
         metadata at a node";

      leaf pot-profile-name {
        type string;
        mandatory true;
        description
          "Unique identifier for each proof of transit profile";
      }

      leaf active-profile-index {
        type profile-index-range;
        description
          "Proof of transit profile index that is currently active.
           Will be set in the first hop of the path or chain.
           Other nodes will not use this field.";
      }

      uses pot-profile;
    }
  /*** Container: end ***/
  }
/*** module: end ***/
}
]]></artwork>
          </figure></t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>IANA considerations will be added in a future version of this
      document.</t>
    </section>

    <section title="Manageability Considerations">
      <t>Manageability considerations will be addressed &iacute;n a later
      version of this document.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Different security requirements achieved by the solution approach are
      discussed here.</t>

      <section title="Proof of Transit">
        <t>Proof of correctness and security of the solution approach is per
        Shamir&rsquo;s Secret Sharing Scheme <xref target="SSS"/>.
        Cryptographically speaking it achieves information-theoretic security
        i.e., it cannot be broken by an attacker even with unlimited computing
        power. As long as the below conditions are met it is impossible for an
        attacker to bypass one or multiple nodes without getting caught.</t>

        <t><list style="symbols">
            <t>If there are k+1 nodes in the path, the polynomials (POLY-1,
            POLY-2) should be of degree k. Also k+1 points of POLY-1 are
            chosen and assigned to each node respectively. The verifier can
            re-construct the k degree polynomial (POLY-3) only when all the
            points are correctly retrieved.</t>

            <t>The Shares of the SECRET (i.e., points on POLY-1 ) are kept
            secret by individual nodes.</t>
          </list> An attacker bypassing a few nodes will miss adding a
        respective point on POLY-1 to corresponding point on POLY-2 , thus the
        verifier cannot construct POLY-3 for cross verification.</t>
      </section>

      <section title="Anti Replay">
        <t>A passive attacker observing CML values across nodes (i.e., as the
        packets entering and leaving), cannot perform differential analysis to
        construct the points on POLY-1 as the operations are done modulo
        prime. The solution approach is flexible, one could use different
        points on POLY-1 or different polynomials as POLY-1 across different
        paths, traffic profiles or service chains.</t>

        <t>Doing differential analysis across packets could be mitigated with
        POLY-2 being be random. Further an attacker could reuse a set of RND
        and all the intermediate CML values to bypass certain nodes in later
        packets. Such attacks could be avoided by carefully choosing POLY-2 as
        a timestamp concatenated with a random string. The verifier could use
        the timestamp to mitigate reuse within a time window.</t>
      </section>

      <section title="Anti Tampering">
        <t>An active attacker could not insert any arbitrary value for CML.
        This would subsequently fail the reconstruction of the POLY-3. Also an
        attacker could not update the CML with a previously observed value.
        This could subsequently be detected by using timestamps within the RND
        value as discussed above.</t>
      </section>

      <section title="Recycling">
        <t>The solution approach is flexible for recycling long term secrets
        like POLY-1. All the nodes could be periodically updated with shares
        of new SECRET as best practice. The table above could be consulted for
        refresh cycles (see <xref target="metadata-for-pot"/>).</t>
      </section>

      <section title="Redundant Nodes and Failover">
        <t>A "node" or "service" in terms of POT can be implemented by one or
        multiple physical entities. In case of multiple physical entities
        (e.g., for load-balancing, or business continuity situations -
        consider for example a set of firewalls), all physical entities which
        are implementing the same POT node are given that same share of the
        secret. This makes multiple physical entities represent the same POT
        node from an algorithm perspective.</t>
      </section>

      <section title="Controller Operation">
        <t>The Controller needs to be secured given that it creates and holds
        the secrets, as need to be the nodes. The communication between
        Controller and the nodes also needs to be secured. As secure
        communication protocol such as for example Netconf over SSH should be
        chosen for Controller to node communication.</t>

        <t>The Controller only interacts with the nodes during the initial
        configuration and thereafter at regular intervals at which the
        operator chooses to switch to a new set of secrets. In case 64 bits
        are used for the data-records "CML" and "RND" which are carried within
        the data packet, the regular intervals are expected to be quite long
        (e.g., at 100 Gbps, a profile would only be used up after 3100 years)
        - see <xref target="metadata-for-pot"/> above, thus even a "headless"
        operation without a Controller can be considered feasible. In such a
        case, the Controller would only be used for the initial configuration
        of the POT-profiles.</t>
      </section>

      <section title="Verification Scope">
        <t>The POT solution defined in this document verifies that a
        data-packet traversed or transited a specific set of nodes. From an
        algorithm perspective, a "node" is an abstract entity. It could be
        represented by one or multiple physical or virtual network devices, or
        is could be a component within a networking device or system. The
        latter would be the case if a forwarding path within a device would
        need to be securely verified.</t>

        <section title="Node Ordering">
          <t>POT using Shamir's secret sharing scheme as discussed in this
          document provides for a means to verify that a set of nodes has been
          visited by a data packet. It does not verify the order in which the
          data packet visited the nodes. In case the order in which a data
          packet traversed a particular set of nodes needs to be verified as
          well, alternate schemes that e.g., rely on nested encryption could
          to be considered.</t>
        </section>

        <section title="Stealth Nodes">
          <t>The POT approach discussed in this document is to prove that a
          data packet traversed a specific set of "nodes". This set could be
          all nodes within a path, but could also be a subset of nodes in a
          path. Consequently, the POT approach isn't suited to detect whether
          "stealth" nodes which do not participate in proof-of-transit have
          been inserted into a path.</t>
        </section>
      </section>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
      Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
      Nadahalli, and Andrew Yourtchenko for the comments and advice.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC7665;

      <reference anchor="SSS"
                 target="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">
        <front>
          <title>Shamir's Secret Sharing</title>

          <author fullname="Wikipedia"/>

          <date/>
        </front>
      </reference>

      <reference anchor="draft-kitamura-ipv6-record-route">
        <front>
          <title>Record Route for IPv6 (PR6),Hop-by-Hop Option
          Extension</title>

          <author fullname="H. Kitamura" initials="H" surname="Kitamura"/>

          <date month="November" year="2000"/>
        </front>
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="draft-brockners-inband-oam-requirements">
        <front>
          <title>Requirements for in-band OAM</title>

          <author fullname="Frank Brockners" initials="F." surname="Brockners">
            <organization/>
          </author>

          <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
            <organization/>
          </author>

          <author fullname="Sashank Dara" initials="S." surname="Dara">
            <organization/>
          </author>

          <date day="8" month="July" year="2016"/>
        </front>
      </reference>

      <reference anchor="draft-brockners-inband-oam-data">
        <front>
          <title>Data Formats for in-band OAM</title>

          <author fullname="Frank Brockners" initials="F." surname="Brockners">
            <organization/>
          </author>

          <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
            <organization/>
          </author>

          <date day="8" month="July" year="2016"/>
        </front>
      </reference>

      <reference anchor="draft-brockners-inband-oam-transport">
        <front>
          <title>Encapsulations for in-band OAM</title>

          <author fullname="Frank Brockners" initials="F." surname="Brockners">
            <organization/>
          </author>

          <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
            <organization/>
          </author>

          <date day="8" month="July" year="2016"/>
        </front>
      </reference>

      &I-D.SPUD;

      &I-D.draft-ietf-anima-autonomic-control-plane;

      <reference anchor="P4">
        <front>
          <title>P4: In-band Network Telemetry (INT)</title>

          <author fullname="Changhoon Kim" surname="Kim"/>

          <date month="September" year="2015"/>
        </front>
      </reference>

      <reference anchor="FD.io" target="https://fd.io/">
        <front>
          <title>Fast Data Project: FD.io</title>

          <author/>

          <date/>
        </front>
      </reference>
    </references>
  </back>
</rfc>
