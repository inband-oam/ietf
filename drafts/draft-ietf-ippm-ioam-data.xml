<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC7665 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC7799 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7799.xml">
<!ENTITY RFC6830 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6830.xml">
<!ENTITY RFC7276 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7276.xml">
<!ENTITY RFC7112 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7112.xml">
<!ENTITY RFC6833 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6833.xml">
<!ENTITY RFC2460 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC791 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC6564 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6564.xml">
<!ENTITY RFC7820 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7820.xml">
<!ENTITY RFC7821 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7821.xml">
<!ENTITY RFC8126 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY I-D.brockners-inband-oam-requirements SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-inband-oam-requirements.xml">
<!ENTITY I-D.brockners-inband-oam-transport SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-inband-oam-transport.xml">
<!ENTITY I-D.brockners-proof-of-transit SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-proof-of-transit.xml">
<!ENTITY I-D.ietf-spring-segment-routing SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-spring-segment-routing.xml">
<!ENTITY I-D.previdi-isis-segment-routing-extensions SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.previdi-isis-segment-routing-extensions.xml">
<!ENTITY I-D.ietf-ippm-6man-pdm-option SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-ippm-6man-pdm-option.xml">
<!ENTITY I-D.gont-v6ops-ipv6-ehs-in-real-world SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.gont-v6ops-ipv6-ehs-in-real-world.xml">
<!ENTITY I-D.brockners-lisp-sr SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-lisp-sr.xml">
<!ENTITY I-D.hildebrand-spud-prototype SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY I-D.ietf-sfc-nsh SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-sfc-nsh.xml">
<!ENTITY I-D.ietf-6man-segment-routing-header SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-6man-segment-routing-header.xml">
<!ENTITY I-D.ietf-nvo3-vxlan-gpe SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-nvo3-vxlan-gpe.xml">
<!ENTITY I-D.ietf-nvo3-geneve SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-nvo3-geneve.xml">
<!ENTITY I-D.lapukhov-dataplane-probe SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.lapukhov-dataplane-probe.xml">
<!ENTITY I-D.SPUD SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.hildebrand-spud-prototype.xml">
<!ENTITY AFI SYSTEM "http://www.iana.org/assignments/address-family-numbers/address-family-numbers.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ippm-ioam-data-01" ipr="trust200902">
  <!-- ipr="full3978"-->

  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="In-situ OAM Data Fields">Data Fields for In-situ
    OAM</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Frank Brockners" initials="F." surname="Brockners">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Hansaallee 249, 3rd Floor</street>

          <!-- Reorder these if your country does things differently -->

          <city>DUESSELDORF</city>

          <region>NORDRHEIN-WESTFALEN</region>

          <code>40549</code>

          <country>Germany</country>
        </postal>

        <email>fbrockne@cisco.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>Bangalore, KARNATAKA 560 087</city>

          <country>India</country>
        </postal>

        <email>shwethab@cisco.com</email>
      </address>
    </author>

    <author fullname="Carlos Pignataro" initials="C." surname="Pignataro">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>7200-11 Kit Creek Road</street>

          <city>Research Triangle Park</city>

          <region>NC</region>

          <code>27709</code>

          <country>United States</country>
        </postal>

        <email>cpignata@cisco.com</email>
      </address>
    </author>

    <author fullname="Hannes Gredler" initials="H." surname="Gredler">
      <organization>RtBrick Inc.</organization>

      <address>
        <email>hannes@rtbrick.com</email>
      </address>
    </author>

    <author fullname="John Leddy" initials="J." surname="Leddy">
      <organization abbrev="Comcast">Comcast</organization>

      <address>
        <email>John_Leddy@cable.comcast.com</email>
      </address>
    </author>

    <author fullname="Stephen Youell" initials="S." surname="Youell">
      <organization abbrev="JPMC">JP Morgan Chase</organization>

      <address>
        <postal>
          <street>25 Bank Street</street>

          <city>London</city>

          <code>E14 5JP</code>

          <country>United Kingdom</country>
        </postal>

        <email>stephen.youell@jpmorgan.com</email>
      </address>
    </author>

    <author fullname="Tal Mizrahi" initials="T." surname="Mizrahi">
      <organization abbrev="">Marvell</organization>

      <address>
        <postal>
          <street>6 Hamada St.</street>

          <city>Yokneam</city>

          <code>2066721</code>

          <country>Israel</country>
        </postal>

        <email>talmi@marvell.com</email>
      </address>
    </author>

    <author fullname="David Mozes" initials="D." surname="Mozes">
      <organization abbrev="">Mellanox Technologies Ltd.</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <code/>

          <country/>
        </postal>

        <email>davidm@mellanox.com</email>
      </address>
    </author>

    <author fullname="Petr Lapukhov" initials="P." surname="Lapukhov">
      <organization abbrev="">Facebook</organization>

      <address>
        <postal>
          <street>1 Hacker Way</street>

          <city>Menlo Park, CA</city>

          <code>94025</code>

          <country>US</country>
        </postal>

        <email>petr@fb.com</email>
      </address>
    </author>

    <author fullname="Remy Chang" initials="R." surname="Chang">
      <organization abbrev="">Barefoot Networks</organization>

      <address>
        <postal>
          <street>2185 Park Boulevard</street>

          <city>Palo Alto, CA</city>

          <code>94306</code>

          <country>US</country>
        </postal>

        <email/>
      </address>
    </author>

    <author fullname="Daniel" initials="D." surname="Bernier">
      <organization abbrev="">Bell Canada</organization>

      <address>
        <postal>
          <street/>

          <city/>

          <code/>

          <country/>
        </postal>

        <email>daniel.bernier@bell.ca</email>
      </address>
    </author>

    <date day="30" month="October" year="2017"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>tsv</area>

    <workgroup>ippm</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>inband</keyword>

    <keyword>Telemetry, Tracing,</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>In-situ Operations, Administration, and Maintenance (IOAM) records
      operational and telemetry information in the packet while the packet
      traverses a path between two points in the network. This document
      discusses the data fields and associated data types for in-situ OAM.
      In-situ OAM data fields can be embedded into a variety of transports
      such as NSH, Segment Routing, Geneve, native IPv6 (via extension
      header), or IPv4. In-situ OAM can be used to complement OAM mechanisms
      based on e.g. ICMP or other types of probe packets.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" toc="default">
      <t>This document defines data fields for "in-situ" Operations,
      Administration, and Maintenance (IOAM). In-situ OAM records OAM
      information within the packet while the packet traverses a particular
      network domain. The term "in-situ" refers to the fact that the OAM data
      is added to the data packets rather than is being sent within packets
      specifically dedicated to OAM. A discussion of the motivation and
      requirements for in-situ OAM can be found in <xref
      target="I-D.brockners-inband-oam-requirements"/>. IOAM is to complement
      mechanisms such as Ping or Traceroute, or more recent active probing
      mechanisms as described in <xref
      target="I-D.lapukhov-dataplane-probe"/>. In terms of "active" or
      "passive" OAM, "in-situ" OAM can be considered a hybrid OAM type. While
      no extra packets are sent, IOAM adds information to the packets
      therefore cannot be considered passive. In terms of the classification
      given in <xref target="RFC7799"/> IOAM could be portrayed as Hybrid Type
      1. "In-situ" mechanisms do not require extra packets to be sent and
      hence don't change the packet traffic mix within the network. IOAM
      mechanisms can be leveraged where mechanisms using e.g. ICMP do not
      apply or do not offer the desired results, such as proving that a
      certain traffic flow takes a pre-defined path, SLA verification for the
      live data traffic, detailed statistics on traffic distribution paths in
      networks that distribute traffic across multiple paths, or scenarios in
      which probe traffic is potentially handled differently from regular data
      traffic by the network devices.</t>
    </section>

    <section anchor="Conventions" title="Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>

      <t>Abbreviations used in this document:</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="E2E">Edge to Edge</t>

          <t hangText="Geneve:">Generic Network Virtualization Encapsulation
          <xref target="I-D.ietf-nvo3-geneve"/></t>

          <t hangText="IOAM:">In-situ Operations, Administration, and
          Maintenance</t>

          <t hangText="MTU:">Maximum Transmit Unit</t>

          <t hangText="NSH:">Network Service Header <xref
          target="I-D.ietf-sfc-nsh"/></t>

          <t hangText="OAM:">Operations, Administration, and Maintenance</t>

          <t hangText="POT:">Proof of Transit</t>

          <t hangText="SFC:">Service Function Chain</t>

          <t hangText="SID:">Segment Identifier</t>

          <t hangText="SR:">Segment Routing</t>

          <t hangText="VXLAN-GPE:">Virtual eXtensible Local Area Network,
          Generic Protocol Extension <xref
          target="I-D.ietf-nvo3-vxlan-gpe"/></t>
        </list></t>
    </section>

    <section title="Scope, Applicability, and Assumptions ">
      <t>IOAM deployment assumes a set of constraints, requirements, and
      guiding principles which are described in this section.</t>

      <t>Scope: This document defines the data fields and associated data
      types for in-situ OAM. The in-situ OAM data field can be transported by
      a variety of transport protocols, including NSH, Segment Routing,
      Geneve, IPv6, or IPv4. Specification details for these different
      transport protocols are outside the scope of this document.</t>

      <t>Deployment domain (or scope) of in-situ OAM deployment: IOAM is a
      network domain focused feature, with "network domain" being a set of
      network devices or entities within a single administration. For example,
      a network domain can include an enterprise campus using physical
      connections between devices or an overlay network using virtual
      connections / tunnels for connectivity between said devices. A network
      domain is defined by its perimeter or edge. Designers of carrier
      protocols for IOAM must specify mechanisms to ensure that IOAM data
      stays within an IOAM domain. In addition, the operator of such a domain
      is expected to put provisions in place to ensure that IOAM data does not
      leak beyond the edge of an IOAM domain, e.g. using for example packet
      filtering methods. The operator should consider potential operational
      impact of IOAM to mechanisms such as ECMP processing (e.g.
      load-balancing schemes based on packet length could be impacted by the
      increased packet size due to IOAM), path MTU (i.e. ensure that the MTU
      of all links within a domain is sufficiently large to support the
      increased packet size due to IOAM) and ICMP message handling (i.e. in
      case of a native IPv6 transport, IOAM support for ICMPv6 Echo
      Request/Reply could desired which would translate into ICMPv6 extensions
      to enable IOAM data fields to be copied from an Echo Request message to
      an Echo Reply message).</t>

      <t>IOAM control points: IOAM data fields are added to or removed from
      the live user traffic by the devices which form the edge of a domain.
      Devices within an IOAM domain can update and/or add IOAM data-fields.
      Domain edge devices can be hosts or network devices.</t>

      <t>Traffic-sets that IOAM is applied to: IOAM can be deployed on all or
      only on subsets of the live user traffic. It SHOULD be possible to
      enable IOAM on a selected set of traffic (e.g., per interface, based on
      an access control list or flow specification defining a specific set of
      traffic, etc.) The selected set of traffic can also be all traffic.</t>

      <t>Encapsulation independence: Data formats for IOAM SHOULD be defined
      in a transport-independent manner. IOAM applies to a variety of
      encapsulating protocols. A definition of how IOAM data fields are
      carried by different transport protocols is outside the scope of this
      document.</t>

      <t>Layering: If several encapsulation protocols (e.g., in case of
      tunneling) are stacked on top of each other, IOAM data-records could be
      present at every layer. The behavior follows the ships-in-the-night
      model.</t>

      <t>Combination with active OAM mechanisms: IOAM should be usable for
      active network probing, enabling for example a customized version of
      traceroute. Decapsulating IOAM nodes may have an ability to send the
      IOAM information retrieved from the packet back to the source address of
      the packet or to the encapsulating node.</t>

      <t>IOAM implementation: The IOAM data-field definitions take the
      specifics of devices with hardware data-plane and software data-plane
      into account.</t>
    </section>

    <section anchor="IOAM_option_format" title="IOAM Data Types and Formats">
      <t>This section defines IOAM data types and data fields and associated
      data types required for IOAM. The different uses of IOAM require the
      definition of different types of data. The IOAM data fields for the data
      being carried corresponds to the three main categories of IOAM data
      defined in <xref target="I-D.brockners-inband-oam-requirements"/>, which
      are: edge-to-edge, per node, and for selected nodes only.</t>

      <t>Transport options for IOAM data are outside the scope of this memo,
      and are discussed in <xref
      target="I-D.brockners-inband-oam-transport"/>. IOAM data fields are
      fixed length data fields. A bit field determines the set of OAM data
      fields embedded in a packet. Depending on the type of the encapsulation,
      a counter field indicates how many data fields are included in a
      particular packet.</t>

      <t>IOAM is expected to be deployed in a specific domain rather than on
      the overall Internet. The part of the network which employs IOAM is
      referred to as the "IOAM-domain". IOAM data is added to a packet upon
      entering the IOAM-domain and is removed from the packet when exiting the
      domain. Within the IOAM-domain, the IOAM data may be updated by network
      nodes that the packet traverses. The device which adds an IOAM data
      container to the packet to capture IOAM data is called the "IOAM
      encapsulating node", whereas the device which removes the IOAM data
      container is referred to as the "IOAM decapsulating node". Nodes within
      the domain which are aware of IOAM data and read and/or write or process
      the IOAM data are called "IOAM transit nodes". IOAM nodes which add or
      remove the IOAM data container can also update the IOAM data fields at
      the same time. Or in other words, IOAM encapsulation or decapsulating
      nodes can also serve as IOAM transit nodes at the same time. Note that
      not every node in an IOAM domain needs to be an IOAM transit node. For
      example, a Segment Routing deployment might require the segment routing
      path to be verified. In that case, only the SR nodes would also be IOAM
      transit nodes rather than all nodes.</t>

      <section anchor="IOAM_tracing_option" title="IOAM Tracing Options">
        <t>"IOAM tracing data" is expected to be collected at every node that
        a packet traverses to ensure visibility into the entire path a packet
        takes within an IOAM domain, i.e., in a typical deployment all nodes
        in an in-situ OAM-domain would participate in IOAM and thus be IOAM
        transit nodes, IOAM encapsulating or IOAM decapsulating nodes. If not
        all nodes within a domain are IOAM capable, IOAM tracing information
        will only be collected on those nodes which are IOAM capable. Nodes
        which are not IOAM capable will forward the packet without any changes
        to the IOAM data fields. The maximum number of hops and the minimum
        path MTU of the IOAM domain is assumed to be known.</t>

        <t>To optimize hardware and software implementations tracing is
        defined as two separate options. Any deployment MAY choose to
        configure and support one or both of the following options. An
        implementation of the transport protocol that carries these in-situ
        OAM data MAY choose to support only one of the options. In the event
        that both options are utilized at the same time, the Incremental Trace
        Option MUST be placed before the Pre-allocated Trace Option. Given
        that the operator knows which equipment is deployed in a particular
        IOAM, the operator will decide by means of configuration which type(s)
        of trace options will be enabled for a particular domain.</t>

        <t><list style="hanging">
            <t hangText="Pre-allocated Trace Option:">This trace option is
            defined as a container of node data fields with pre-allocated
            space for each node to populate its information. This option is
            useful for software implementations where it is efficient to
            allocate the space once and index into the array to populate the
            data during transit. The IOAM encapsulating node allocates the
            option header and sets the fields in the option header. The in
            situ OAM encapsulating node allocates an array which is used to
            store operational data retrieved from every node while the packet
            traverses the domain. IOAM transit nodes update the content of the
            array. A pointer which is part of the IOAM trace data points to
            the next empty slot in the array, which is where the next IOAM
            transit node fills in its data.</t>

            <t hangText="Incremental Trace Option:">This trace option is
            defined as a container of node data fields where each node
            allocates and pushes its node data immediately following the
            option header. The maximum length of the node data list is written
            into the option header. This type of trace recording is useful for
            some of the hardware implementations as this eliminates the need
            for the transit network elements to read the full array in the
            option and allows for arbitrarily long packets as the MTU allows.
            The in-situ OAM encapsulating node allocates the option header.
            The in-situ OAM encapsulating node based on operational state and
            configuration sets the fields in the header to control how large
            the node data list can grow. IOAM transit nodes push their node
            data to the node data list and increment the number of node data
            fields in the header.</t>
          </list></t>

        <t>Every node data entry is to hold information for a particular IOAM
        transit node that is traversed by a packet. The in-situ OAM
        decapsulating node removes the IOAM data and processes and/or exports
        the metadata. IOAM data uses its own name-space for information such
        as node identifier or interface identifier. This allows for a
        domain-specific definition and interpretation. For example: In one
        case an interface-id could point to a physical interface (e.g., to
        understand which physical interface of an aggregated link is used when
        receiving or transmitting a packet) whereas in another case it could
        refer to a logical interface (e.g., in case of tunnels).</t>

        <t>The following IOAM data is defined for IOAM tracing:</t>

        <t><list style="symbols">
            <t>Identification of the IOAM node. An IOAM node identifier can
            match to a device identifier or a particular control point or
            subsystem within a device.</t>

            <t>Identification of the interface that a packet was received on,
            i.e. ingress interface.</t>

            <t>Identification of the interface that a packet was sent out on,
            i.e. egress interface.</t>

            <t>Time of day when the packet was processed by the node.
            Different definitions of processing time are feasible and
            expected, though it is important that all devices of an in-situ
            OAM domain follow the same definition.</t>

            <t>Generic data: Format-free information where syntax and semantic
            of the information is defined by the operator in a specific
            deployment. For a specific deployment, all IOAM nodes should
            interpret the generic data the same way. Examples for generic IOAM
            data include geo-location information (location of the node at the
            time the packet was processed), buffer queue fill level or cache
            fill level at the time the packet was processed, or even a battery
            charge level.</t>

            <t>A mechanism to detect whether IOAM trace data was added at
            every hop or whether certain hops in the domain weren't in-situ
            OAM transit nodes.</t>
          </list>The "node data list" array in the packet is populated
        iteratively as the packet traverses the network, starting with the
        last entry of the array, i.e., "node data list [n]" is the first entry
        to be populated, "node data list [n-1]" is the second one, etc.</t>

        <section anchor="TraceOptionDef" title="Pre-allocated Trace Option">
          <t><figure>
              <artwork><![CDATA[ 
In-situ OAM pre-allocated trace option: 

Pre-allocated trace option header:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         IOAM-Trace-Type       |NodeLen|  Flags  | Octets-left |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Pre-allocated Trace Option Data MUST be 4-octet aligned:
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+
|                                                               |  |
|                        node data list [0]                     |  |
|                                                               |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  D
|                                                               |  a
|                        node data list [1]                     |  t
|                                                               |  a
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
~                             ...                               ~  S
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  p
|                                                               |  a
|                        node data list [n-1]                   |  c
|                                                               |  e
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                                                               |  |
|                        node data list [n]                     |  |
|                                                               |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+


]]></artwork>
            </figure> <list style="hanging">
              <t anchor="IOAMTraceType" hangText="IOAM-Trace-Type:">A 16-bit
              identifier which specifies which data types are used in this
              node data list.</t>

              <t hangText=" ">The IOAM-Trace-Type value is a bit field. The
              following bit fields are defined in this document, with details
              on each field described in the <xref
              target="trace-node-data-element"/>. The order of packing the
              data fields in each node data element follows the bit order of
              the IOAM-Trace-Type field, as follows:<list hangIndent="9"
                  style="hanging">
                  <t hangText="Bit 0">(Most significant bit) When set
                  indicates presence of Hop_Lim and node_id in the node
                  data.</t>

                  <t hangText="Bit 1">When set indicates presence of
                  ingress_if_id and egress_if_id (short format) in the node
                  data.</t>

                  <t hangText="Bit 2">When set indicates presence of timestamp
                  seconds in the node data</t>

                  <t hangText="Bit 3">When set indicates presence of timestamp
                  nanoseconds in the node data.</t>

                  <t hangText="Bit 4">When set indicates presence of transit
                  delay in the node data.</t>

                  <t hangText="Bit 5">When set indicates presence of app_data
                  (short format) in the node data.</t>

                  <t hangText="Bit 6">When set indicates presence of queue
                  depth in the node data.</t>

                  <t hangText="Bit 7">When set indicates presence of variable
                  length Opaque State Snapshot field.</t>

                  <t hangText="Bit 8">When set indicates presence of Hop_Lim
                  and node_id in wide format in the node data.</t>

                  <t hangText="Bit 9">When set indicates presence of
                  ingress_if_id and egress_if_id in wide format in the node
                  data.</t>

                  <t hangText="Bit 10">When set indicates presence of app_data
                  wide in the node data.</t>

                  <t hangText="Bit 11">When set indicates presence of the
                  Checksum Complement node data.</t>

                  <t hangText="Bit 12-15">Undefined in this draft.</t>
                </list></t>

              <t hangText=" "><xref target="trace-node-data-element"/>
              describes the IOAM data types and their formats. Within an
              in-situ OAM domain possible combinations of these bits making
              the IOAM-Trace-Type can be restricted by configuration
              knobs.</t>

              <t hangText="NodeLen:">4-bit unsigned integer. This field
              specifies the length of data added by each node in multiples of
              4-octets. For example, if 3 IOAM-Trace-Type bits are set and
              none of them is wide, then the NodeLen would be 3. If 3
              IOAM-Trace-Type bits are set and 2 of them are wide, then the
              NodeLen would be 5.</t>

              <t anchor="TraceFlags" hangText="Flags">5-bit field. Following
              flags are defined:<list style="hanging">
                  <t hangText="Bit 0">"Overflow" (O-bit) (most significant
                  bit). This bit is set by the network element if there is not
                  enough number of octets left to record node data, no field
                  is added and the overflow "O-bit" must be set to "1" in the
                  header. This is useful for transit nodes to ignore further
                  processing of the option.</t>

                  <t hangText="Bit 1">"Loopback" (L-bit). Loopback mode is
                  used to send a copy of a packet back towards the source.
                  Loopback mode assumes that a return path from transit nodes
                  and destination nodes towards the source exists. The
                  encapsulating node decides (e.g. using a filter) which
                  packets loopback mode is enabled for by setting the loopback
                  bit. The encapsulating node also needs to ensure that
                  sufficient space is available in the IOAM header for
                  loopback operation. The loopback bit when set indicates to
                  the transit nodes processing this option to create a copy of
                  the packet received and send this copy of the packet back to
                  the source of the packet while it continues to forward the
                  original packet towards the destination. The source address
                  of the original packet is used as destination address in the
                  copied packet. The address of the node performing the copy
                  operation is used as the source address. The L-bit MUST be
                  cleared in the copy of the packet a nodes sends it back
                  towards the source. On its way back towards the source, the
                  packet is processed like a regular packet with IOAM
                  information. Once the return packet reaches the IOAM domain
                  boundary IOAM decapsulation occurs as with any other packet
                  containing IOAM information.</t>

                  <t hangText="Bit 2-4">Reserved: Must be zero.</t>
                </list></t>

              <t hangText="Octets-left:">7-bit unsigned integer. It is the
              data space in multiples of 4-octets remaining for recording the
              node data. This is used as an offset in data space to record the
              node data element.</t>

              <t hangText="Node data List [n]:">Variable-length field. The
              type of which is determined by the IOAM-Trace-Type representing
              the n-th node data in the node data list. The node data list is
              encoded starting from the last node data of the path. The first
              element of the node data list (node data list [0]) contains the
              last node of the path while the last node data of the node data
              list (node data list[n]) contains the first node data of the
              path traced. The index contained in "Octets-left" identifies the
              offset for current active node data to be populated.</t>
            </list></t>
        </section>

        <section title="Incremental Trace Option">
          <t><figure>
              <artwork><![CDATA[ 
In-situ OAM incremental trace option: 

In-situ OAM incremental trace option Header:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        IOAM-Trace-Type        |NodeLen|  Flags  | Max Length  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

IOAM Incremental Trace Option Data MUST be 4-octet aligned: 

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                        node data list [0]                     |
|                                                               | 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                        node data list [1]                     |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
~                             ...                               ~ 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                        node data list [n-1]                   |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
|                        node data list [n]                     |
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


]]></artwork>
            </figure><list style="hanging">
              <t hangText="IOAM-trace-type:">A 16-bit identifier which
              specifies which data types are used in this node data list.</t>

              <t hangText=" ">The IOAM-Trace-Type value is a bit field. The
              following bit fields are defined in this document, with details
              on each field described in the <xref
              target="trace-node-data-element"/>. The order of packing the
              data fields in each node data element follows the bit order of
              the IOAM-Trace-Type field, as follows:<list hangIndent="9"
                  style="hanging">
                  <t hangText="Bit 0">(Most significant bit) When set
                  indicates presence of Hop_Lim and node_id in the node
                  data.</t>

                  <t hangText="Bit 1">When set indicates presence of
                  ingress_if_id and egress_if_id (short format) in the node
                  data.</t>

                  <t hangText="Bit 2">When set indicates presence of timestamp
                  seconds in the node data.</t>

                  <t hangText="Bit 3">When set indicates presence of timestamp
                  nanoseconds in the node data.</t>

                  <t hangText="Bit 4">When set indicates presence of transit
                  delay in the node data.</t>

                  <t hangText="Bit 5">When set indicates presence of app_data
                  in the node data.</t>

                  <t hangText="Bit 6">When set indicates presence of queue
                  depth in the node data.</t>

                  <t hangText="Bit 7">When set indicates presence of variable
                  length Opaque State Snapshot field.</t>

                  <t hangText="Bit 8">When set indicates presence of Hop_Lim
                  and node_id wide in the node data.</t>

                  <t hangText="Bit 9">When set indicates presence of
                  ingress_if_id and egress_if_id in wide format in the node
                  data.</t>

                  <t hangText="Bit 10">When set indicates presence of app_data
                  wide in the node data.</t>

                  <t hangText="Bit 11">When set indicates presence of the
                  Checksum Complement node data.</t>

                  <t hangText="Bit 12-15">Undefined in this draft.</t>
                </list></t>

              <t hangText=" "><xref target="trace-node-data-element"/>
              describes the IOAM data types and their formats.</t>

              <t hangText="NodeLen:">4-bit unsigned integer. This field
              specifies the length of data added by each node in multiples of
              4-octets. For example, if 3 IOAM-Trace-Type bits are set and
              none of them is wide, then the NodeLen would be 3. If 3
              IOAM-Trace-Type bits are set and 2 of them are wide, then the
              NodeLen would be 5.</t>

              <t anchor="IOAMTraceFlags" hangText="Flags">5-bit field.
              Following flags are defined:<list style="hanging">
                  <t hangText="Bit 0">"Overflow" (O-bit) (most significant
                  bit). This bit is set by the network element if there is not
                  enough number of octets left to record node data, no field
                  is added and the overflow "O-bit" must be set to "1" in the
                  header. This is useful for transit nodes to ignore further
                  processing of the option.</t>

                  <t hangText="Bit 1">"Loopback" (L-bit). This bit when set
                  indicates to the transit nodes processing this option to
                  send a copy of the packet back to the source of the packet
                  while it continues to forward the original packet towards
                  the destination. The L-bit MUST be cleared in the copy of
                  the packet before sending it.</t>

                  <t hangText="Bit 2-4">Reserved. Must be zero.</t>
                </list></t>

              <t hangText="Maximum Length:">7-bit unsigned integer. This field
              specifies the maximum length of the node data list in multiples
              of 4-octets. Given that the sender knows the minimum path MTU,
              the sender can set the maximum length according to the number of
              node data bytes allowed before exceeding the MTU. Thus, a simple
              comparison between "NodeLen" and "Max Length" allows to decide
              whether or not data could be added.</t>

              <t hangText="Node data List [n]:">Variable-length field. The
              type of which is determined by the OAM Type representing the
              n-th node data in the node data list. The node data list is
              encoded starting from the last node data of the path. The first
              element of the node data list (node data list [0]) contains the
              last node of the path while the last node data of the node data
              list (node data list[n]) contains the first node data of the
              path traced.</t>
            </list></t>
        </section>

        <section anchor="trace-node-data-element"
                 title="IOAM node data fields and associated formats">
          <t>All the data fields MUST be 4-octet aligned. The IOAM
          encapsulating node MUST initialize data fields that it adds to the
          packet to zero. If a node which is supposed to update an IOAM data
          field is not capable of populating the value of a field set in the
          IOAM-Trace-Type, the field value MUST be left unaltered except when
          explicitly specified in the field description below. In the
          description of data below if zero is valid value then a non-zero
          value to mean not populated is specified.</t>

          <t>Data field and associated data type for each of the data field is
          shown below:</t>

          <t><list style="hanging">
              <t hangText="Hop_Lim and node_id:">4-octet field defined as
              follows: <figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Hop_Lim     |              node_id                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure><list style="hanging">
                  <t hangText="Hop_Lim:">1-octet unsigned integer. It is set
                  to the Hop Limit value in the packet at the node that
                  records this data. Hop Limit information is used to identify
                  the location of the node in the communication path. This is
                  copied from the lower layer, e.g., TTL value in IPv4 header
                  or hop limit field from IPv6 header of the packet when the
                  packet is ready for transmission. The semantics of the
                  Hop_Lim field depend on the lower layer protocol that IOAM
                  is encapsulated over, and therefore its specific semantics
                  are outside the scope of this memo.</t>

                  <t hangText="node_id:">3-octet unsigned integer. Node
                  identifier field to uniquely identify a node within in-situ
                  OAM domain. The procedure to allocate, manage and map the
                  node_ids is beyond the scope of this document.</t>
                </list></t>

              <t hangText="ingress_if_id and egress_if_id:">4-octet field
              defined as follows: When this field is part of the data field
              but a node populating the field is not able to fill it, the
              position in the field must be filled with value 0xFFFFFFFF to
              mean not populated.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     ingress_if_id             |         egress_if_id          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure><list style="hanging">
                  <t hangText="ingress_if_id:">2-octet unsigned integer.
                  Interface identifier to record the ingress interface the
                  packet was received on.</t>

                  <t hangText="egress_if_id:">2-octet unsigned integer.
                  Interface identifier to record the egress interface the
                  packet is forwarded out of.</t>
                </list></t>

              <t hangText="timestamp seconds:">4-octet unsigned integer.
              Absolute timestamp in seconds that specifies the time at which
              the packet was received by the node. The structure of this field
              is identical to the most significant 32 bits of the 64 least
              significant bits of the <xref target="IEEE1588v2"/> timestamp.
              This truncated field consists of a 32-bit seconds field. As
              defined in <xref target="IEEE1588v2"/>, the timestamp specifies
              the number of seconds elapsed since 1 January 1970 00:00:00
              according to the International Atomic Time (TAI).<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       timestamp seconds                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>

              <t hangText="timestamp nanoseconds:">4-octet unsigned integer in
              the range 0 to 10^9-1. This timestamp specifies the fractional
              part of the wall clock time at which the packet was received by
              the node in units of nanoseconds. This field is identical to the
              32 least significant bits of the <xref target="IEEE1588v2"/>
              timestamp. This fields allows for delay computation between any
              two nodes in the network when the nodes are time synchronized.
              When this field is part of the data field but a node populating
              the field is not able to fill it, the field position in the
              field must be filled with value 0xFFFFFFFF to mean not
              populated.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       timestamp nanoseconds                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>

              <t hangText="transit delay:">4-octet unsigned integer in the
              range 0 to 2^31-1. It is the time in nanoseconds the packet
              spent in the transit node. This can serve as an indication of
              the queuing delay at the node. If the transit delay exceeds
              2^31-1 nanoseconds then the top bit 'O' is set to indicate
              overflow and value set to 0x80000000. When this field is part of
              the data field but a node populating the field is not able to
              fill it, the field position in the field must be filled with
              value 0xFFFFFFFF to mean not populated.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|O|                     transit delay                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>

              <t hangText="app_data:">4-octet placeholder which can be used by
              the node to add application specific data. App_data represents a
              "free-format" 4-octet bit field with its semantics defined by a
              specific deployment.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       app_data                                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>

              <t hangText="queue depth:">4-octet unsigned integer field. This
              field indicates the current length of the egress interface queue
              of the interface from where the packet is forwarded out. The
              queue depth is expressed as the current number of memory buffers
              used by the queue (a packet may consume one or more memory
              buffers, depending on its size). When this field is part of the
              data field but a node populating the field is not able to fill
              it, the field position in the field must be filled with value
              0xFFFFFFFF to mean not populated.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       queue depth                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>

              <t hangText="Opaque State Snapshot:">Variable length field. It
              allows the network element to store an arbitrary state in the
              node data field , without a pre-defined schema. The schema needs
              to be made known to the analyzer by some out-of-band mechanism.
              The specification of this mechanism is beyond the scope of this
              document. The 24-bit "Schema Id" field in the field indicates
              which particular schema is used, and should be configured on the
              network element by the operator. <figure>
                  <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Length      |                     Schema ID                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                                                               |
   |                        Opaque data                            |
   ~                                                               ~
   .                                                               .
   .                                                               .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure><list style="hanging">
                  <t hangText="Length:">1-octet unsigned integer. It is the
                  length in octets of the Opaque data field that follows
                  Schema Id. It MUST always be a multiple of 4.</t>

                  <t hangText="Schema ID:">3-octet unsigned integer
                  identifying the schema of Opaque data.</t>

                  <t hangText="Opaque data:">Variable length field. This field
                  is interpreted as specified by the schema identified by the
                  Schema ID.</t>
                </list></t>

              <t hangText="Hop_Lim and node_id wide:">8-octet field defined as
              follows: <figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Hop_Lim     |              node_id                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                         node_id (contd)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure><list style="hanging">
                  <t hangText="Hop_Lim:">1-octet unsigned integer. It is set
                  to the Hop Limit value in the packet at the node that
                  records this data. Hop Limit information is used to identify
                  the location of the node in the communication path. This is
                  copied from the lower layer for e.g. TTL value in IPv4
                  header or hop limit field from IPv6 header of the packet.
                  The semantics of the Hop_Lim field depend on the lower layer
                  protocol that IOAM is encapsulated over, and therefore its
                  specific semantics are outside the scope of this memo.</t>

                  <t hangText="node_id:">7-octet unsigned integer. Node
                  identifier field to uniquely identify a node within in-situ
                  OAM domain. The procedure to allocate, manage and map the
                  node_ids is beyond the scope of this document.</t>
                </list></t>

              <t hangText="ingress_if_id and egress_if_id wide:">8-octet field
              defined as follows: When this field is part of the data field
              but a node populating the field is not able to fill it, the
              field position in the field must be filled with value
              0xFFFFFFFFFFFFFFFF to mean not populated.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       ingress_if_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       egress_if_id                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure><list style="hanging">
                  <t hangText="ingress_if_id:">4-octet unsigned integer.
                  Interface identifier to record the ingress interface the
                  packet was received on.</t>

                  <t hangText="egress_if_id:">4-octet unsigned integer.
                  Interface identifier to record the egress interface the
                  packet is forwarded out of.</t>
                </list></t>

              <t hangText="app_data wide:">8-octet placeholder which can be
              used by the node to add application specific data. App data
              represents a "free-format" 8-octed bit field with its semantics
              defined by a specific deployment. <figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       app data                                ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                       app data (contd)                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
                </figure></t>

              <t hangText="Checksum Complement:">4-octet node data which
              contains a two-octet Checksum Complement field, and a 2-octet
              reserved field. The Checksum Complement can be used when IOAM is
              transported over encapsulations that make use of a UDP
              transport, such as VXLAN-GPE or Geneve. In this case,
              incorporating the IOAM node data requires the UDP Checksum field
              to be updated. Rather than to recompute the Chekcsum field, a
              node can use the Checksum Complement to make a checksum-neutral
              update in the UDP payload; the Checksum Complement is assigned a
              value that complements the rest of the node data fields that
              were added by the current node, causing the existing UDP
              Checksum field to remain correct. Checksum Complement fields are
              used in a similar manner in <xref target="RFC7820"/> and <xref
              target="RFC7821"/>.<figure>
                  <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7
8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      Checksum Complement      |           Reserved            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
                </figure></t>
            </list></t>
        </section>

        <section anchor="trace-type-node-data"
                 title=" Examples of IOAM node data">
          <t>An entry in the "node data list" array can have different
          formats, following the needs of the deployment. Some deployments
          might only be interested in recording the node identifiers, whereas
          others might be interested in recording node identifier and
          timestamp. The section defines different types that an entry in
          "node data list" can take.</t>

          <t><list style="hanging">
              <t hangText="0xD400:">IOAM-Trace-Type is 0xD400 then the format
              of node data is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     ingress_if_id             |         egress_if_id          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  timestamp nanoseconds                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            app_data                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0xC000:">IOAM-Trace-Type is 0xC000 then the format
              is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     ingress_if_id             |         egress_if_id          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   

]]></artwork>
                </figure></t>

              <t hangText="0x9000:">IOAM-Trace-Type is 0x9000 then the format
              is: <figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   timestamp nanoseconds                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x8400:">IOAM-Trace-Type is 0x8400 then the format
              is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            app_data                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x9400:">IOAM-Trace-Type is 0x9400 then the format
              is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    timestamp nanoseconds                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            app_data                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x3180:">IOAM-Trace-Type is 0x3180 then the format
              is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      timestamp seconds                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    timestamp nanoseconds                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Length      |                     Schema Id                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                                                               |
    |                        Opaque data                            |
    ~                                                               ~
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         node_id(contd)                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>
            </list></t>
        </section>
      </section>

      <section anchor="IOAM_proof_of_transit_option"
               title="IOAM Proof of Transit Option">
        <t>IOAM Proof of Transit data is to support the path or service
        function chain <xref target="RFC7665"/> verification use cases.
        Proof-of-transit uses methods like nested hashing or nested encryption
        of the IOAM data or mechanisms such as Shamir's Secret Sharing Schema
        (SSSS). While details on how the IOAM data for the proof of transit
        option is processed at IOAM encapsulating, decapsulating and transit
        nodes are outside the scope of the document, all of these approaches
        share the need to uniquely identify a packet as well as iteratively
        operate on a set of information that is handed from node to node.
        Correspondingly, two pieces of information are added as IOAM data to
        the packet:</t>

        <t><list style="symbols">
            <t>Random: Unique identifier for the packet (e.g., 64-bits allow
            for the unique identification of 2^64 packets).</t>

            <t>Cumulative: Information which is handed from node to node and
            updated by every node according to a verification algorithm.</t>
          </list></t>

        <t><figure>
            <artwork><![CDATA[ 
IOAM proof of transit option:

IOAM proof of transit option header:
 
 0 1 2 3 4 5 6 7 
+-+-+-+-+-+-+-+-+
|IOAM POT Type|P|  
+-+-+-+-+-+-+-+-+

IOAM proof of transit option data MUST be 4-octet aligned:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+
|                           Random                              |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  P
|                        Random(contd)                          |  O
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  T
|                         Cumulative                            |  | 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                         Cumulative (contd)                    |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+


]]></artwork>
          </figure><list style="hanging">
            <t hangText="IOAM POT Type:">7-bit identifier of a particular POT
            variant that dictates the POT data that is included. This document
            defines POT Type 0:<list style="hanging">
                <t hangText="0:">POT data is a 16 Octet field as described
                below.</t>
              </list></t>

            <t hangText="Profile to use (P):">1-bit. Indicates which
            POT-profile is used to generate the Cumulative. Any node
            participating in POT will have a maximum of 2 profiles configured
            that drive the computation of cumulative. The two profiles are
            numbered 0, 1. This bit conveys whether profile 0 or profile 1 is
            used to compute the Cumulative.</t>

            <t hangText="Random:">64-bit Per packet Random number.</t>

            <t hangText="Cumulative:">64-bit Cumulative that is updated at
            specific nodes by processing per packet Random number field and
            configured parameters.</t>
          </list>Note: Larger or smaller sizes of "Random" and "Cumulative"
        data are feasible and could be required for certain deployments (e.g.
        in case of space constraints in the transport protocol used). Future
        versions of this document will address different sizes of data for
        "proof of transit".</t>
      </section>

      <section anchor="IOAM_edge_to_edge_opt" title="IOAM Edge-to-Edge Option">
        <t>The IOAM edge-to-edge option is to carry data that is added by the
        IOAM encapsulating node and interpreted by IOAM decapsulating node.
        The IOAM transit nodes MAY process the data without modifying it.</t>

        <t>Currently only sequence numbers use the IOAM edge-to-edge option.
        In order to detect packet loss, packet reordering, or packet
        duplication in an in-situ OAM-domain, sequence numbers can be added to
        packets of a particular tube (see <xref
        target="I-D.hildebrand-spud-prototype"/>). Each tube leverages a
        dedicated namespace for its sequence numbers.</t>

        <t><figure>
            <artwork><![CDATA[
  IOAM edge-to-edge option:

   IOAM edge-to-edge option header:
   
    0 1 2 3 4 5 6 7 
   +-+-+-+-+-+-+-+-+
   | IOAM-E2E-Type |
   +-+-+-+-+-+-+-+-+

   IOAM edge-to-edge option data MUST be 4-octet aligned:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |       E2E Option data field determined by IOAM-E2E-Type       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
          </figure><list style="hanging">
            <t hangText="IOAM-E2E-Type:">8-bit identifier of a particular in
            situ OAM E2E variant.<list style="empty">
                <t>0: E2E option data is a 64-bit sequence number added to a
                specific tube which is used to identify packet loss and
                reordering for that tube.</t>
              </list></t>
          </list></t>
      </section>
    </section>

    <section title="IOAM Data Export">
      <t>IOAM nodes collect information for packets traversing a domain that
      supports IOAM. IOAM decapsulating nodes as well as IOAM transit nodes
      can choose to retrieve IOAM information from the packet, process the
      information further and export the information using e.g., IPFIX.</t>

      <t>The discussion of IOAM data processing and export is left for a
      future version of this document.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document requests the following IANA Actions.</t>

      <section anchor="IANA-Creation"
               title="Creation of a new In-Situ OAM  Protocol Parameters Registry                                (IOAM) Protocol Parameters IANA registry">
        <t>IANA is requested to create a new protocol registry for "In-Situ
        OAM (IOAM) Protocol Parameters". This is the common registry that will
        include registrations for all IOAM namespaces. Each Registry, whose
        names are listed below:</t>

        <t><list style="empty">
            <t>IOAM Trace Type</t>

            <t>IOAM Trace flags</t>

            <t>IOAM POT Type</t>

            <t>IOAM E2E Type</t>
          </list>will contain the current set of possibilities defined in this
        document. New registries in this name space are created via RFC
        Required process as per <xref target="RFC8126"/>.</t>

        <t>The subsequent sub-sections detail the registries herein
        contained.</t>
      </section>

      <section title="IOAM Trace Type Registry">
        <t>This registry defines code point for each bit in the 16-bit
        IOAM-Trace-Type field for Pre-allocated trace option and Incremental
        trace option defined in <xref target="IOAM_tracing_option"/>. The
        meaning of Bit 0 - 11 for trace type are defined in this document in
        <xref target="IOAMTraceType"/> <xref
        target="TraceOptionDef">of</xref>. The meaning for Bit 12 - 15 are
        available for assignment via RFC Required process as per <xref
        target="RFC8126"/>.</t>
      </section>

      <section title="IOAM Trace Flags Registry">
        <t>This registry defines code point for each bit in the 5 bit flags
        for Pre-allocated trace option and Incremental trace option defined in
        <xref target="IOAM_tracing_option"/>. The meaning of Bit 0 - 1 for
        trace flags are defined in this document in <xref
        target="TraceFlags"/> of <xref target="TraceOptionDef"/>. The meaning
        for Bit 2 - 4 are available for assignment via RFC Required process as
        per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM POT Type Registry">
        <t>This registry defines 128 code points to define IOAM POT Type for
        IOAM proof of transit option <xref
        target="IOAM_proof_of_transit_option"/>. The code point value 0 is
        defined in this document, 1 - 127 are available for assignment via RFC
        Required process as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM E2E Type Registry">
        <t>This registry defines 256 code points to define IOAM-E2E-Type for
        IOAM E2E option <xref target="IOAM_edge_to_edge_opt"/>. The code point
        value 0 is defined in this document, 1 - 255 are available for
        assignments via RFC Required process as per <xref
        target="RFC8126"/>.</t>
      </section>
    </section>

    <section title="Manageability Considerations">
      <t>Manageability considerations will be addressed &iacute;n a later
      version of this document..</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>Security considerations will be addressed &iacute;n a later version
      of this document. For a discussion of security requirements of in-situ
      OAM, please refer to <xref
      target="I-D.brockners-inband-oam-requirements"/>.</t>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
      Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
      Nadahalli, LJ Wobker, Erik Nordmark, Vengada Prasad Govindan, and Andrew
      Yourtchenko for the comments and advice.</t>

      <t>This document leverages and builds on top of several concepts
      described in <xref target="I-D.kitamura-ipv6-record-route"/>. The
      authors would like to acknowledge the work done by the author Hiroshi
      Kitamura and people involved in writing it.</t>

      <t>The authors would like to gracefully acknowledge useful review and
      insightful comments received from Joe Clarke, Al Morton, and Mickey
      Spiegel.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;

      &RFC8126;

      <reference anchor="IEEE1588v2"
                 target="http://standards.ieee.org/findstds/standard/1588-2008.html">
        <front>
          <title>1588-2008 - IEEE Standard for a Precision Clock
          Synchronization Protocol for Networked Measurement and Control
          Systems</title>

          <author>
            <organization>Institute of Electrical and Electronics
            Engineers</organization>
          </author>

          <date year="2008"/>
        </front>

        <seriesInfo name="" value="IEEE Std 1588-2008"/>
      </reference>
    </references>

    <references title="Informative References">
      &RFC7665;

      &RFC7799;

      &I-D.brockners-inband-oam-requirements;

      &RFC7820;

      &RFC7821;

      &I-D.lapukhov-dataplane-probe;

      <reference anchor="I-D.kitamura-ipv6-record-route">
        <front>
          <title>Record Route for IPv6 (PR6) Hop-by-Hop Option
          Extension</title>

          <author fullname="Hiroshi Kitamura" initials="H" surname="Kitamura"/>

          <date month="November" year="2000"/>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-kitamura-ipv6-record-route-00"/>

        <format target="https://tools.ietf.org/id/draft-kitamura-ipv6-record-route-00.txt"
                type="TXT"/>
      </reference>

      &I-D.brockners-inband-oam-transport;

      &I-D.SPUD;

      &I-D.ietf-sfc-nsh;

      &I-D.ietf-nvo3-vxlan-gpe;

      &I-D.ietf-nvo3-geneve;
    </references>
  </back>
</rfc>
