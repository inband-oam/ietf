<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC7665 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7665.xml">
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC7799 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7799.xml">
<!ENTITY RFC6830 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6830.xml">
<!ENTITY RFC7276 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7276.xml">
<!ENTITY RFC7112 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7112.xml">
<!ENTITY RFC6833 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6833.xml">
<!ENTITY RFC2460 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2460.xml">
<!ENTITY RFC791 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.0791.xml">
<!ENTITY RFC6564 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6564.xml">
<!ENTITY RFC7820 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7820.xml">
<!ENTITY RFC7821 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7821.xml">
<!ENTITY RFC8126 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml">
<!ENTITY RFC5905 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5905.xml">
<!ENTITY RFC7384 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7384.xml">
<!ENTITY RFC8300 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8300.xml">
<!ENTITY I-D.brockners-opsawg-ioam-deployment SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-opsawg-ioam-deployment.xml">
<!ENTITY I-D.ietf-sfc-proof-of-transit SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-sfc-proof-of-transit.xml">
<!ENTITY I-D.ioamteam-ippm-ioam-direct-export SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ioamteam-ippm-ioam-direct-export.xml">
<!ENTITY I-D.ietf-spring-segment-routing SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-spring-segment-routing.xml">
<!ENTITY I-D.previdi-isis-segment-routing-extensions SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.previdi-isis-segment-routing-extensions.xml">
<!ENTITY I-D.ietf-ippm-6man-pdm-option SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-ippm-6man-pdm-option.xml">
<!ENTITY I-D.gont-v6ops-ipv6-ehs-in-real-world SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.gont-v6ops-ipv6-ehs-in-real-world.xml">
<!ENTITY I-D.brockners-lisp-sr SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.brockners-lisp-sr.xml">
<!ENTITY I-D.ietf-6man-segment-routing-header SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-6man-segment-routing-header.xml">
<!ENTITY I-D.ietf-nvo3-vxlan-gpe SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-nvo3-vxlan-gpe.xml">
<!ENTITY I-D.ietf-nvo3-geneve SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-nvo3-geneve.xml">
<!ENTITY I-D.lapukhov-dataplane-probe SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.lapukhov-dataplane-probe.xml">
<!ENTITY I-D.ietf-ntp-packet-timestamps SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-ntp-packet-timestamps.xml">
<!ENTITY I-D.spiegel-ippm-ioam-rawexport SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml-ids/reference.I-D.spiegel-ippm-ioam-rawexport.xml">
<!ENTITY AFI SYSTEM "http://www.iana.org/assignments/address-family-numbers/address-family-numbers.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs), 
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space 
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-ippm-ioam-data-10" ipr="trust200902">
  <!-- ipr="full3978"-->

  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN" 
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the 
         full title is longer than 39 characters -->

    <title abbrev="In-situ OAM Data Fields">Data Fields for In-situ
    OAM</title>

    <!-- add 'role="editor"' below for the editors if appropriate -->

    <!-- Another author who claims to be an editor -->

    <author fullname="Frank Brockners" initials="F." surname="Brockners" role="editor">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Hansaallee 249, 3rd Floor</street>

          <!-- Reorder these if your country does things differently -->

          <city>DUESSELDORF</city>

          <region>NORDRHEIN-WESTFALEN</region>

          <code>40549</code>

          <country>Germany</country>
        </postal>

        <email>fbrockne@cisco.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Shwetha Bhandari" initials="S." surname="Bhandari" role="editor">
      <organization abbrev="Cisco">Cisco Systems, Inc.</organization>

      <address>
        <postal>
          <street>Cessna Business Park, Sarjapura Marathalli Outer Ring
          Road</street>

          <city>Bangalore, KARNATAKA 560 087</city>

          <country>India</country>
        </postal>

        <email>shwethab@cisco.com</email>
      </address>
    </author>

    <author fullname="Tal Mizrahi" initials="T." surname="Mizrahi" role="editor">
      <organization abbrev="">Huawei</organization>

      <address>
        <postal>
          <street>8-2 Matam</street>

          <city>Haifa</city>

          <code>3190501</code>

          <country>Israel</country>
        </postal>

        <email>tal.mizrahi.phd@gmail.com</email>
      </address>
    </author>

    <date day="13" month="July" year="2020"/>

    <!-- If the month and year are both specified and are the current ones, xml2rfc will fill 
         in the current day for you. If only the current year is specified, xml2rfc will fill 
	 in the current day and month for you. If the year is not the current one, it is 
	 necessary to specify at least a month (xml2rfc assumes day="1" if not specified for the 
	 purpose of calculating the expiry date).  With drafts it is normally sufficient to 
	 specify just the year. -->

    <!-- Meta-data Declarations -->

    <area>tsv</area>

    <workgroup>ippm</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.  
	 If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>inband</keyword>

    <keyword>Telemetry, Tracing,</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>In-situ Operations, Administration, and Maintenance (IOAM) records
      operational and telemetry information in the packet while the packet
      traverses a path between two points in the network. This document
      discusses the data fields and associated data types for in-situ OAM.
      In-situ OAM data fields can be encapsulated into a variety of protocols
      such as NSH, Segment Routing, Geneve, IPv6 (via extension header), or
      IPv4. In-situ OAM can be used to complement OAM mechanisms based on e.g.
      ICMP or other types of probe packets.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction" toc="default">
      <t>This document defines data fields for "in-situ" Operations,
      Administration, and Maintenance (IOAM). In-situ OAM records OAM
      information within the packet while the packet traverses a particular
      network domain. The term "in-situ" refers to the fact that the OAM data
      is added to the data packets rather than being sent within packets
      specifically dedicated to OAM. IOAM is to complement mechanisms such as
      Ping or Traceroute. In terms of "active" or "passive" OAM, "in-situ" OAM
      can be considered a hybrid OAM type. "In-situ" mechanisms do not require
      extra packets to be sent. IOAM adds information to the already available
      data packets and therefore cannot be considered passive. In terms of the
      classification given in <xref target="RFC7799"/> IOAM could be portrayed
      as Hybrid Type 1. IOAM mechanisms can be leveraged where mechanisms
      using e.g. ICMP do not apply or do not offer the desired results, such
      as proving that a certain traffic flow takes a pre-defined path, SLA
      verification for the live data traffic, detailed statistics on traffic
      distribution paths in networks that distribute traffic across multiple
      paths, or scenarios in which probe traffic is potentially handled
      differently from regular data traffic by the network devices.</t>

      <t>IOAM use cases and mechanisms have expanded as this document matured,
      resulting in additional flags and options that could trigger creation of
      additional packets dedicated to OAM. The term IOAM continues to be used
      for such mechanisms, in addition to the "in-situ" mechanisms that
      motivated this terminology.</t>
    </section>

	<section title="Contributors">
	  <t>This document was the collective effort of several authors. The text
	  and content were contributed by the editors and the co-authors listed 
	  below. The contact information of the co-authors appears at the end of
	  this document.</t>

        <t><list style="symbols">
            <t>Carlos Pignataro</t>
			<t>Mickey Spiegel</t>
			<t>Barak Gafni</t>
			<t>Jennifer Lemon</t>
			<t>Hannes Gredler</t>
			<t>John Leddy</t>
			<t>Stephen Youell</t>
			<t>David Mozes</t>
			<t>Petr Lapukhov</t>
			<t>Remy Chang</t>
			<t>Daniel Bernier</t>
          </list></t>
	  
	
	</section>
	
    <section anchor="Conventions" title="Conventions">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref
      target="RFC2119"/>.</t>

      <t>Abbreviations used in this document:</t>

      <t><list hangIndent="11" style="hanging">
          <t hangText="E2E">Edge to Edge</t>

          <t hangText="Geneve:">Generic Network Virtualization Encapsulation
          <xref target="I-D.ietf-nvo3-geneve"/></t>

          <t hangText="IOAM:">In-situ Operations, Administration, and
          Maintenance</t>

          <t hangText="MTU:">Maximum Transmit Unit</t>

          <t hangText="NSH:">Network Service Header <xref
          target="RFC8300"/></t>

          <t hangText="OAM:">Operations, Administration, and Maintenance</t>

          <t hangText="PMTU">Path MTU</t>

          <t hangText="POT:">Proof of Transit</t>

          <t hangText="SFC:">Service Function Chain</t>

          <t hangText="SID:">Segment Identifier</t>

          <t hangText="SR:">Segment Routing</t>

          <t hangText="VXLAN-GPE:">Virtual eXtensible Local Area Network,
          Generic Protocol Extension <xref
          target="I-D.ietf-nvo3-vxlan-gpe"/></t>
        </list></t>
    </section>

    <section title="Scope, Applicability, and Assumptions ">
      <t>IOAM deployment assumes a set of constraints, requirements, and
      guiding principles which are described in this section.</t>

      <t>Scope: This document defines the data fields and associated data
      types for in-situ OAM. The in-situ OAM data field can be encapsulated in
      a variety of protocols, including NSH, Segment Routing, Geneve, IPv6, or
      IPv4. Specification details for these different protocols are outside
      the scope of this document.</t>

      <t>Deployment domain (or scope) of in-situ OAM deployment: IOAM is a
      network domain focused feature, with "network domain" being a set of
      network devices or entities within a single administration. For example,
      a network domain can include an enterprise campus using physical
      connections between devices or an overlay network using virtual
      connections / tunnels for connectivity between said devices. A network
      domain is defined by its perimeter or edge. Designers of protocol
      encapsulations for IOAM specify mechanisms to ensure that IOAM data
      stays within an IOAM domain. In addition, the operator of such a domain
      is expected to put provisions in place to ensure that IOAM data does not
      leak beyond the edge of an IOAM domain using,for example, packet
      filtering methods. The operator has to consider the potential
      operational impact of IOAM to mechanisms such as ECMP processing (e.g.
      load-balancing schemes based on packet length could be impacted by the
      increased packet size due to IOAM), path MTU (i.e. ensure that the MTU
      of all links within a domain is sufficiently large to support the
      increased packet size due to IOAM) and ICMP message handling (i.e. in
      case of IPv6, IOAM support for ICMPv6 Echo Request/Reply is desired
      which would translate into ICMPv6 extensions to enable IOAM-Data-Fields
      to be copied from an Echo Request message to an Echo Reply message).</t>

      <t>IOAM control points: IOAM-Data-Fields are added to or removed from
      the live user traffic by the devices which form the edge of a domain.
      Devices which form an IOAM-Domain can add, update or remove
      IOAM-Data-Fields. Edge devices of an IOAM-Domain can be hosts or network
      devices.</t>

      <t>Traffic-sets that IOAM is applied to: IOAM can be deployed on all or
      only on subsets of the live user traffic. Using IOAM on a selected set
      of traffic (e.g., per interface, based on an access control list or flow
      specification defining a specific set of traffic, etc.) could be useful
      in deployments where the cost of processing IOAM-Data-Fields by
      encapsulating, transit, or decapsulating node(s) might be a concern from
      a performance or operational perspective. Thus limiting the amount of
      traffic IOAM is applied to could be beneficial in some deployments.</t>

      <t>Encapsulation independence: The definition of IOAM-Data-Fields is
      independent from the protocols the IOAM-Data-Fields are encapsulated
      into. IOAM-Data-Fields can be encapsulated into several encapsulating
      protocols. The specification of how IOAM-Data-Fields are encapsulated
      into "parent" protocols, like e.g., NSH or IPv6 is outside the scope of
      this document.</t>

      <t>Layering: If several encapsulation protocols (e.g., in case of
      tunneling) are stacked on top of each other, IOAM-Data-Fields could be
      present at multiple layers. The behavior follows the ships-in-the-night
      model, i.e. IOAM-Data-Fields in one layer are independent from
      IOAM-Data-Fields in another layer. Layering allows operators to
      instrument the protocol layer they want to measure. The different layers
      could, but do not have to, share the same IOAM encapsulation
      mechanisms.</t>

      <t>IOAM implementation: The definition of the IOAM-Data-Fields take the
      specifics of devices with hardware data planes and software data planes
      into account.</t>
    </section>

    <section anchor="IOAM_option_format"
             title="IOAM Data-Fields, Types, Nodes">
      <t>This section details IOAM-related nomenclature and describes data
      types such as IOAM-Data-Fields, IOAM-Types, IOAM-Namespaces as well as
      the different types of IOAM nodes.</t>

      <section title="IOAM Data-Fields and Option-Types">
        <t>An IOAM-Data-Field is a set of bits with a defined format and
        meaning, which can be stored at a certain place in a packet for the
        purpose of IOAM.</t>

        <t>To accommodate the different uses of IOAM, IOAM-Data-Fields fall
        into different categories. In IOAM these categories are referred to as
        IOAM-Option-Types. A common registry is maintained for
        IOAM-Option-Types, see <xref target="IOAM-type-registry"/> for
        details. Corresponding to these IOAM-Option-Types, different
        IOAM-Data-Fields are defined. IOAM-Data-Fields can be encapsulated
        into a variety of protocols, such as NSH, Geneve, IPv6, etc. The
        definition of how IOAM-Data-Fields are encapsulated into other
        protocols is outside the scope of this document.</t>

        <t>This document defines four IOAM-Option-Types:<list style="symbols">
            <t>Pre-allocated Trace Option-Type</t>

            <t>Incremental Trace Option-Type</t>

            <t>Proof of Transit (POT) Option-Type</t>

            <t>Edge-to-Edge (E2E) Option-Type</t>
          </list></t>
      </section>

      <section title="IOAM-Domains and types of IOAM Nodes">
        <t>IOAM is expected to be deployed in a specific domain. The part of
        the network which employs IOAM is referred to as the "IOAM-Domain".
        One or more IOAM-Option-Types are added to a packet upon entering the
        IOAM-Domain and are removed from the packet when exiting the domain.
        Within the IOAM-Domain, the IOAM-Data-Fields MAY be updated by network
        nodes that the packet traverses. An IOAM-Domain consists of "IOAM
        encapsulating nodes", "IOAM decapsulating nodes" and "IOAM transit
        nodes". The role of a node (i.e. encapsulating, transit,
        decapsulating) is defined within an IOAM-Namespace (see below). A node
        can have different roles in different IOAM-Namespaces.</t>

        <t>A device which adds at least one IOAM-Option-Type to the packet is
        called the "IOAM encapsulating node", whereas a device which removes
        an IOAM-Option-Type is referred to as the "IOAM decapsulating node".
        Nodes within the domain which are aware of IOAM data and read and/or
        write or process the IOAM data are called "IOAM transit nodes". IOAM
        nodes which add or remove the IOAM-Data-Fields can also update the
        IOAM-Data-Fields at the same time. Or in other words, IOAM
        encapsulating or decapsulating nodes can also serve as IOAM transit
        nodes at the same time. Note that not every node in an IOAM domain
        needs to be an IOAM transit node. For example, a deployment might
        require that packets traverse a set of firewalls which support IOAM.
        In that case, only the set of firewall nodes would be IOAM transit
        nodes rather than all nodes.</t>

        <t>An "IOAM encapsulating node" incorporates one or more
        IOAM-Option-Types (from the list of IOAM-Types, see <xref
        target="IOAM-type-registry"/>) into packets that IOAM is enabled for.
        If IOAM is enabled for a selected subset of the traffic, the IOAM
        encapsulating node is responsible for applying the IOAM functionality
        to the selected subset.</t>

        <t>An "IOAM transit node" updates one or more of the IOAM-Data-Fields.
        If both the Pre-allocated and the Incremental Trace Option-Types are
        present in the packet, each IOAM transit node based on configuration and
	available implementation of IOAM populates IOAM trace data in
	either Pre-allocated or Incremental Trace Option-Type but not both.
        A transit node MUST ignore IOAM-Option-Types that it does not
        understand. A transit node MUST NOT add new IOAM-Option-Types to a
        packet, MUST NOT remove IOAM-Option-Types from a packet, and
        MUST NOT change the IOAM-Data-Fields of an IOAM Edge-to-Edge
        Option-Type.</t>

        <t>An "IOAM decapsulating node" removes IOAM-Option-Type(s) from
        packets.</t>

        <t>The role of an IOAM-encapsulating, IOAM-transit or
        IOAM-decapsulating node is always performed within a specific
        IOAM-Namespace. This means that an IOAM node which is e.g. an
        IOAM-decapsulating node for IOAM-Namespace "A" but not for
        IOAM-Namespace "B" will only remove the IOAM-Option-Types for
        IOAM-Namespace "A" from the packet. Note that this applies even
        for IOAM-Option-Types that the node does not understand, for
        example an IOAM-Option-Type other than the four described above,
        that is added in a future revision. An IOAM decapsulating node
        situated at the edge of an IOAM domain MUST remove all
        IOAM-Option-Types and associated encapsulation headers for all
        IOAM-Namespaces from the packet.</t>

        <t>IOAM-Namespaces allow for a namespace-specific definition and
        interpretation of IOAM-Data-Fields. An interface-id could for example
        point to a physical interface (e.g., to understand which physical
        interface of an aggregated link is used when receiving or transmitting
        a packet) whereas in another case it could refer to a logical
        interface (e.g., in case of tunnels). Please refer to <xref
        target="ioam_namespaces"/> for details on IOAM-Namespaces.</t>
      </section>

      <section anchor="ioam_namespaces" title="IOAM-Namespaces">
        <t>A subset or all of the IOAM-Option-Types and their corresponding
        IOAM-Data-Fields can be associated to an IOAM-Namespace.
        IOAM-Namespaces add further context to IOAM-Option-Types and
        associated IOAM-Data-Fields. Any IOAM-Namespace MUST interpret the
        IOAM-Option-Types and associated IOAM-Data-Fields per the definition
        in this document. IOAM-Namespaces group nodes to support different
        deployment approaches of IOAM (see a few example use-cases below) as
        well as resolve issues which can occur due to IOAM-Data-Fields not
        being globally unique (e.g. IOAM node identifiers do not have to be
        globally unique). IOAM-Data-Fields significance is always within a
        particular IOAM-Namespace.</t>

        <t>An IOAM-Namespace is identified by a 16-bit namespace identifier
        (Namespace-ID). IOAM-Namespace identifiers MUST be present and
        populated in all IOAM-Option-Types. The Namespace-ID value is divided
        into two sub-ranges:</t>

        <t><list style="symbols">
            <t>An operator-assigned range from 0x0001 to 0x7FFF</t>

            <t>An IANA-assigned range from 0x8000 to 0xFFFF</t>
          </list>The IANA-assigned range is intended to allow future
        extensions to have new and interoperable IOAM functionality, while the
        operator-assigned range is intended to be domain specific, and managed
        by the network operator. The Namespace-ID value of 0x0000 is default
        and known to all the nodes implementing IOAM.</t>

        <t>Namespace identifiers allow devices which are IOAM capable to
        determine:</t>

        <t><list style="symbols">
            <t>whether IOAM-Option-Type(s) need to be processed by a device:
            If the Namespace-ID contained in a packet does not match any
            Namespace-ID the node is configured to operate on, then the node
            MUST NOT change the contents of the IOAM-Data-Fields.</t>

            <t>which IOAM-Option-Type needs to be processed/updated in case
            there are multiple IOAM-Option-Types present in the packet.
            Multiple IOAM-Option-Types can be present in a packet in case of
            overlapping IOAM-Domains or in case of a layered IOAM
            deployment.</t>

            <t>whether IOAM-Option-Type(s) has to be removed from the packet,
            e.g. at a domain edge or domain boundary.</t>
          </list></t>

        <t>IOAM-Namespaces support several different uses:</t>

        <t><list style="symbols">
            <t>IOAM-Namespaces can be used by an operator to distinguish
            different operational domains. Devices at domain edges can filter
            on Namespace-IDs to provide for proper IOAM-Domain isolation.</t>

            <t>IOAM-Namespaces provide additional context for IOAM-Data-Fields
            and thus ensure that IOAM-Data-Fields are unique and can be
            interpreted properly by management stations or network
            controllers. While, for example, the node identifier field
            (node_id, see below) does not need to be unique in a deployment
            (e.g. if an operator wishes to use different node identifiers for
            different IOAM layers, even within the same device; or node
            identifiers might not be unique for other organizational reasons,
            such as after a merger of two formerly separated organizations),
            the combination of node_id and Namespace-ID will always be unique.
            Similarly, IOAM-Namespaces can be used to define how certain
            IOAM-Data-Fields are interpreted: IOAM offers three different
            timestamp format options. The Namespace-ID can be used to
            determine the timestamp format. IOAM-Data-Fields (e.g. buffer
            occupancy) which do not have a unit associated are to be
            interpreted within the context of a IOAM-Namespace.</t>

            <t>IOAM-Namespaces can be used to identify different sets of
            devices (e.g., different types of devices) in a deployment: If an
            operator desires to insert different IOAM-Data-Fields based on the
            device, the devices could be grouped into multiple
            IOAM-Namespaces. This could be due to the fact that the IOAM
            feature set differs between different sets of devices, or it could
            be for reasons of optimized space usage in the packet header. It
            could also stem from hardware or operational limitations on the
            size of the trace data that can be added and processed, preventing
            collection of a full trace for a flow.<list style="symbols">
                <t>Assigning different IOAM Namespace-IDs to different sets of
                nodes or network partitions and using the Namespace-ID as a
                selector at the IOAM encapsulating node, a full trace for a
                flow could be collected and constructed via partial traces in
                different packets of the same flow. Example: An operator could
                choose to group the devices of a domain into two
                IOAM-Namespaces, in a way that on average, only every second
                hop would be recorded by any device. To retrieve a full view
                of the deployment, the captured IOAM-Data-Fields of the two
                IOAM-Namespaces need to be correlated.</t>

                <t>Assigning different IOAM Namespace-IDs to different sets of
                nodes or network partitions and using a separate instance of
                an IOAM-Option-Type for each Namespace-ID, a full trace for a
                flow could be collected and constructed via partial traces
                from each IOAM-Option-Type in each of the packets in the flow.
                Example: An operator could choose to group the devices of a
                domain into two IOAM-Namespaces, in a way that each
                IOAM-Namespace is represented by one of two IOAM-Option-Types
                in the packet. Each node would record data only for the
                IOAM-Namespace that it belongs to, ignoring the other
                IOAM-Option-Type with a IOAM-Namespace to which it doesn't
                belong. To retrieve a full view of the deployment, the
                captured IOAM-Data-Fields of the two IOAM-Namespaces need to
                be correlated.</t>
              </list></t>
          </list></t>
      </section>

      <section anchor="IOAM_tracing_option" title="IOAM Trace Option-Types">
        <t>"IOAM tracing data" is expected to be either collected at every
        IOAM transit node that a packet traverses to ensure visibility into
        the entire path a packet takes within an IOAM-Domain. I.e., in a
        typical deployment all nodes in an IOAM-Domain would participate in
        IOAM and thus be IOAM transit nodes, IOAM encapsulating or IOAM
        decapsulating nodes. If not all nodes within a domain support IOAM
        functionality as defined in this document, IOAM tracing information
        (i.e., node data, see below) will only be collected on those nodes
        which support IOAM functionality as defined in this document. Nodes
        which do not support IOAM functionality as defined in this document
        will forward the packet without any changes to the IOAM-Data-Fields.
        The maximum number of hops and the minimum path MTU of the IOAM domain
        is assumed to be known. An overflow indicator (O-bit) is defined
	as one of the ways to deal with situations where the PMTU
	was underestimated, i.e. where the number of hops which
	are IOAM capable exceeds the available space in the packet.</t>

        <t>To optimize hardware and software implementations, IOAM tracing is
        defined as two separate options. Any deployment MAY choose to
        configure and support one or both of the following options.</t>

        <t><list style="hanging">
            <t hangText="Pre-allocated Trace-Option:">This trace option is
            defined as a container of node data fields (see below) with
            pre-allocated space for each node to populate its information.
            This option is useful for implementations where it is efficient to
            allocate the space once and index into the array to populate the
            data during transit (e.g., software forwarders often fall into
            this class). The IOAM encapsulating node allocates space for
            Pre-allocated Trace Option-Type in the packet and sets
            corresponding fields in this IOAM-Option-Type. The IOAM
            encapsulating node allocates an array which is used to store
            operational data retrieved from every node while the packet
            traverses the domain. IOAM transit nodes update the content of the
            array, and possibly update the checksums of outer headers. A
            pointer which is part of the IOAM trace data, points to the next
            empty slot in the array. An IOAM transit node that updates the
            content of the pre-allocated option also updates the value of the
            pointer, which specifies where the next IOAM transit node fills in
            its data. The "node data list" array (see below) in the packet is
            populated iteratively as the packet traverses the network,
            starting with the last entry of the array, i.e., "node data list
            [n]" is the first entry to be populated, "node data list [n-1]" is
            the second one, etc.</t>

            <t hangText="Incremental Trace-Option:">This trace option is
            defined as a container of node data fields where each node
            allocates and pushes its node data immediately following the
            option header. This type of trace recording is useful for some of
            the hardware implementations as it eliminates the need for the
            transit network elements to read the full array in the option and
            allows for arbitrarily long packets as the MTU allows. The IOAM
            encapsulating node allocates space for the Incremental Trace
            Option-Type. Based on operational state and configuration, the
            IOAM encapsulating node sets the fields in the Option-Type that
            control what IOAM-Data-Fields have to be collected and how large
            the node data list can grow. IOAM transit nodes push their node
            data to the node data list, decrease the remaining length
            available to subsequent nodes and adjust the lengths and possibly
            checksums in outer headers.</t>
          </list></t>

        <t>A particular implementation of IOAM MAY choose to support only one
        of the two trace option types. In the event that both options are
        utilized at the same time, the Incremental Trace-Option MUST be placed
        before the Pre-allocated Trace-Option. Deployments which mix devices
        with either the Incremental Trace-Option or the Pre-allocated
        Trace-Option could result in both Option-Types being present in a
        packet. Given that the operator knows which equipment is deployed in a
        particular IOAM, the operator will decide by means of configuration
        which type(s) of trace options will be used for a particular
        domain.</t>

        <t>Every node data entry holds information for a particular IOAM
        transit node that is traversed by a packet. The IOAM decapsulating
        node removes the IOAM-Option-Type(s) and processes and/or exports the
        associated data. Like all IOAM-Data-Fields, the IOAM-Data-Fields of
        the IOAM-Trace-Option-Types are defined in the context of an
        IOAM-Namespace.</t>

        <t>IOAM tracing can collect the following types of information:</t>

        <t><list style="symbols">
            <t>Identification of the IOAM node. An IOAM node identifier can
            match to a device identifier or a particular control point or
            subsystem within a device.</t>

            <t>Identification of the interface that a packet was received on,
            i.e. ingress interface.</t>

            <t>Identification of the interface that a packet was sent out on,
            i.e. egress interface.</t>

            <t>Time of day when the packet was processed by the node as well
            as the transit delay. Different definitions of processing time are
            feasible and expected, though it is important that all devices of
            an in-situ OAM domain follow the same definition.</t>

            <t>Generic data: Format-free information where syntax and semantic
            of the information is defined by the operator in a specific
            deployment. For a specific IOAM-Namespace, all IOAM nodes have to
            interpret the generic data the same way. Examples for generic IOAM
            data include geo-location information (location of the node at the
            time the packet was processed), buffer queue fill level or cache
            fill level at the time the packet was processed, or even a battery
            charge level.</t>

            <t>Information to detect whether IOAM trace data was added at
            every hop or whether certain hops in the domain weren't IOAM
            transit nodes.</t>
          </list></t>

        <section anchor="TraceOptionDef"
                 title="Pre-allocated and Incremental Trace Option-Types">
          <t>The IOAM Pre-allocated Trace-Option and the IOAM Incremental
          Trace-Option have similar formats. Except where noted below, the
          internal formats and fields of the two trace options are identical.
          Both Trace-Options consist of a fixed size "trace option header" and
          a variable data space to store gathered data, the "node data list".
          An IOAM transit node (that is not an IOAM encapsulating node or IOAM
          decapsulating node) MUST NOT modify any of the fields in the fixed
          size &ldquo;trace option header&rdquo;, other than
          &ldquo;flags&rdquo; and &ldquo;RemainingLen&rdquo;, i.e. an IOAM
          transit node MUST NOT modify the Namespace-ID, NodeLen,
          IOAM-Trace-Type, or Reserved fields.</t>

          <t><figure>
              <artwork><![CDATA[ 
Pre-allocated and incremental trace option headers:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Namespace-ID           |NodeLen  | Flags | RemainingLen|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               IOAM-Trace-Type                 |  Reserved     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


The trace option data MUST be 4-octet aligned:

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+
|                                                               |  |
|                        node data list [0]                     |  |
|                                                               |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  D
|                                                               |  a
|                        node data list [1]                     |  t
|                                                               |  a
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  
~                             ...                               ~  S
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  p
|                                                               |  a
|                        node data list [n-1]                   |  c
|                                                               |  e
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                                                               |  |
|                        node data list [n]                     |  |
|                                                               |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+


]]></artwork>
            </figure> <list style="hanging">
              <t hangText="Namespace-ID:">16-bit identifier of an
              IOAM-Namespace. The Namespace-ID value of 0x0000 is defined as
              the default value and MUST be known to all the nodes
              implementing IOAM. For any other Namespace-ID value that does
              not match any Namespace-ID the node is configured to operate on,
              the node MUST NOT change the contents of the
              IOAM-Data-Fields.</t>

              <t hangText="NodeLen:">5-bit unsigned integer. This field
              specifies the length of data added by each node in multiples of
              4-octets, excluding the length of the "Opaque State Snapshot"
              field. <vspace blankLines="1"/>If IOAM-Trace-Type bit 22 is not
              set, then NodeLen specifies the actual length added by each
              node. If IOAM-Trace-Type bit 22 is set, then the actual length
              added by a node would be (NodeLen + length of the "Opaque State
              Snapshot" field) in 4 octet units. <vspace blankLines="1"/>For
              example, if 3 IOAM-Trace-Type bits are set and none of them are
              wide, then NodeLen would be 3. If 3 IOAM-Trace-Type bits are set
              and 2 of them are wide, then NodeLen would be 5. <vspace
              blankLines="1"/>An IOAM encapsulating node MUST set NodeLen.
              <vspace blankLines="1"/>A node receiving an IOAM Pre-allocated
              or Incremental Trace-Option relies on the NodeLen value, or it
              can ignore the NodeLen value and calculate the node length from
              the IOAM-Trace-Type bits (see below).</t>

              <t anchor="TraceFlags" hangText="Flags">4-bit field. Flags are
              allocated by IANA, as specified in <xref
              target="Flags-Registry-Sec"/>. This document allocates a single
              flag as follows: <list style="hanging">
                  <t hangText="Bit 0">"Overflow" (O-bit) (most significant
                  bit). If there are not enough octets left to record node
                  data, the network element MUST NOT add any fields and MUST set
                  the overflow "O-bit" to "1" in the IOAM-Trace-Option header.
                  This is useful for transit nodes to ignore further
                  processing of the option.</t>
                </list></t>

              <t hangText="RemainingLen:">7-bit unsigned integer. This field
              specifies the data space in multiples of 4-octets remaining for
              recording the node data, before the node data list is considered
              to have overflowed. Given that the sender knows the path MTU
              (PMTU), the sender MAY set the initial value of RemainingLen
              according to the number of node data bytes allowed before
              exceeding the MTU. Subsequent nodes can carry out a simple
              comparison between RemainingLen and NodeLen, along with the
              length of the "Opaque State Snapshot" if applicable, to
              determine whether or not data can be added by this node. When
              node data is added, the node MUST decrease RemainingLen by the
              amount of data added. In the pre-allocated trace option,
              RemainingLen is used to derive the offset in data space to
              record the node data element. Specifically, the recording of the
              node data element would start from RemainingLen - NodeLen -
              sizeof(opaque snapshot) in 4 octet units. If RemainingLen
              in a pre-allocated trace option exceeds the length of the
              option, as specified in the preceding header, then the node
              MUST NOT add any fields.</t>

              <t anchor="IOAMTraceType" hangText="IOAM-Trace-Type:">A 24-bit
              identifier which specifies which data types are used in this
              node data list.</t>

              <t hangText=" ">The IOAM-Trace-Type value is a bit field. The
              following bits are defined in this document, with details on
              each bit described in the <xref
              target="trace-node-data-element"/>. The order of packing the
              data fields in each node data element follows the bit order of
              the IOAM-Trace-Type field, as follows:<list hangIndent="9"
                  style="hanging">
                  <t hangText="Bit 0">(Most significant bit) When set,
                  indicates presence of Hop_Lim and node_id (short format) in
                  the node data.</t>

                  <t hangText="Bit 1">When set, indicates presence of
                  ingress_if_id and egress_if_id (short format) in the node
                  data.</t>

                  <t hangText="Bit 2">When set, indicates presence of
                  timestamp seconds in the node data.</t>

                  <t hangText="Bit 3">When set, indicates presence of
                  timestamp subseconds in the node data.</t>

                  <t hangText="Bit 4">When set, indicates presence of transit
                  delay in the node data.</t>

                  <t hangText="Bit 5">When set, indicates presence of
                  IOAM-Namespace specific data (short format) in the node
                  data.</t>

                  <t hangText="Bit 6">When set, indicates presence of queue
                  depth in the node data.</t>

                  <t hangText="Bit 7">When set, indicates presence of the
                  Checksum Complement node data.</t>

                  <t hangText="Bit 8">When set, indicates presence of Hop_Lim
                  and node_id in wide format in the node data.</t>

                  <t hangText="Bit 9">When set, indicates presence of
                  ingress_if_id and egress_if_id in wide format in the node
                  data.</t>

                  <t hangText="Bit 10">When set, indicates presence of
                  IOAM-Namespace specific data in wide format in the node
                  data.</t>

                  <t hangText="Bit 11">When set, indicates presence of buffer
                  occupancy in the node data.</t>

                  <t hangText="Bit 12-21">Undefined. An IOAM encapsulating
                  node MUST set the value of each of these bits to 0. If an
                  IOAM transit node receives a packet with one or more of
                  these bits set to 1, it MUST either: <list style="numbers">
                      <t>Add corresponding node data filled with the reserved
                      value 0xFFFFFFFF, after the node data fields for the
                      IOAM-Trace-Type bits defined above, such that the total
                      node data added by this node in units of 4-octets is
                      equal to NodeLen, or</t>

                      <t>Not add any node data fields to the packet, even for
                      the IOAM-Trace-Type bits defined above.</t>
                    </list></t>

                  <t hangText="Bit 22">When set, indicates presence of
                  variable length Opaque State Snapshot field.</t>

                  <t hangText="Bit 23">Reserved: MUST be set to zero upon
                  transmission and ignored upon receipt.</t>
                </list></t>

              <t hangText=" "><xref target="trace-node-data-element"/>
              describes the IOAM-Data-Types and their formats. Within an
              IOAM-Domain possible combinations of these bits making the
              IOAM-Trace-Type can be restricted by configuration knobs.</t>

              <t hangText="Reserved:">8-bits. An IOAM encapsulating node MUST
              set the value to zero upon transmission. IOAM transit nodes MUST
              ignore the received value.</t>

              <t hangText="Node data List [n]:">Variable-length field. This is
              a list of node data elements where the content of each node data
              element is determined by the IOAM-Trace-Type. The order of
              packing the data fields in each node data element follows the
              bit order of the IOAM-Trace-Type field. Each node MUST prepend
              its node data element in front of the node data elements that it
              received, such that the transmitted node data list begins with
              this node's data element as the first populated element in the
              list. The last node data element in this list is the node data
              of the first IOAM capable node in the path. Populating the node
              data list in this way ensures that the order of node data list
              is the same for incremental and pre-allocated trace options. In
              the pre-allocated trace option, the index contained in
              RemainingLen identifies the offset for current active node data
              to be populated.</t>
            </list></t>
        </section>

        <section anchor="trace-node-data-element"
                 title="IOAM node data fields and associated formats">
          <t>All the IOAM-Data-Fields MUST be 4-octet aligned. If a node which
          is supposed to update an IOAM-Data-Field is not capable of
          populating the value of a field set in the IOAM-Trace-Type, the
          field value MUST be set to 0xFFFFFFFF for 4-octet fields or
          0xFFFFFFFFFFFFFFFF for 8-octet fields, indicating that the value is
          not populated, except when explicitly specified in the field
          description below.</t>

          <t>Some IOAM-Data-Fields defined below, such as interface
          identifiers or IOAM-Namespace specific data, are defined in both
          "short format" as well as "wide format". Their use is not exclusive.
          A deployment could choose to leverage both. For example,
          ingress_if_id_(short format) could be an identifier for the physical
          interface, whereas ingress_if_id_(wide format) could be an
          identifier for a logical sub-interface of that physical
          interface.</t>

          <t>Data fields and associated data types for each of the
          IOAM-Data-Fields are specified in the following sections.</t>

          <section title="Hop_Lim and node_id short format">
            <t>The "Hop_Lim and node_id short format" field is a 4-octet field
            that is defined as follows: <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Hop_Lim     |              node_id                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure><list style="hanging">
                <t hangText="Hop_Lim:">1-octet unsigned integer. It is set to
                the Hop Limit value in the packet at the node that records
                this data. Hop Limit information is used to identify the
                location of the node in the communication path. This is copied
                from the lower layer, e.g., TTL value in IPv4 header or hop
                limit field from IPv6 header of the packet when the packet is
                ready for transmission. The semantics of the Hop_Lim field
                depend on the lower layer protocol that IOAM is encapsulated
                into, and therefore its specific semantics are outside the
                scope of this memo. The value of this field MUST be set to
                0xff when the lower level does not have a TTL/Hop limit
                equivalent field.</t>

                <t hangText="node_id:">3-octet unsigned integer. Node
                identifier field to uniquely identify a node within the
                IOAM-Namespace and associated IOAM-Domain. The procedure to
                allocate, manage and map the node_ids is beyond the scope of
                this document.</t>
              </list></t>
          </section>

          <section title="ingress_if_id and egress_if_id">
            <t>The "ingress_if_id and egress_if_id" field is a 4-octet field
            that is defined as follows: <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     ingress_if_id             |         egress_if_id          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure><list style="hanging">
                <t hangText="ingress_if_id:">2-octet unsigned integer.
                Interface identifier to record the ingress interface the
                packet was received on.</t>

                <t hangText="egress_if_id:">2-octet unsigned integer.
                Interface identifier to record the egress interface the packet
                is forwarded out of.</t>
              </list>Note that due to the fact that IOAM uses its own
            IOAM-Namespaces for IOAM-Data-Fields, data fields like interface
            identifiers can be used in a flexible way to represent system
            resources that are associated with ingressing or egressing
            packets, i.e. ingress_if_id could represent a physical interface,
            a virtual or logical interface, or even a queue.</t>
          </section>

          <section title="timestamp seconds">
            <t>The "timestamp seconds" field is a 4-octet unsigned integer
            field. Absolute timestamp in seconds that specifies the time at
            which the packet was received by the node. This field has three
            possible formats; based on either PTP <xref target="IEEE1588v2"/>,
            NTP <xref target="RFC5905"/>, or POSIX <xref target="POSIX"/>. The
            three timestamp formats are specified in <xref
            target="TimestampSec"/>. In all three cases, the Timestamp Seconds
            field contains the 32 most significant bits of the timestamp
            format that is specified in <xref target="TimestampSec"/>. If a
            node is not capable of populating this field, it assigns the value
            0xFFFFFFFF. Note that this is a legitimate value that is valid for
            1 second in approximately 136 years; the analyzer has to correlate
            several packets or compare the timestamp value to its own
            time-of-day in order to detect the error indication.</t>
          </section>

          <section title="timestamp subseconds">
            <t>The "timestamp subseconds" field is a 4-octet unsigned integer
            field. Absolute timestamp in subseconds that specifies the time at
            which the packet was received by the node. This field has three
            possible formats; based on either PTP <xref target="IEEE1588v2"/>,
            NTP <xref target="RFC5905"/>, or POSIX <xref target="POSIX"/>. The
            three timestamp formats are specified in <xref
            target="TimestampSec"/>. In all three cases, the Timestamp
            Subseconds field contains the 32 least significant bits of the
            timestamp format that is specified in <xref
            target="TimestampSec"/>. If a node is not capable of populating
            this field, it assigns the value 0xFFFFFFFF. Note that this is a
            legitimate value in the NTP format, valid for approximately 233
            picoseconds in every second. If the NTP format is used the
            analyzer has to correlate several packets in order to detect the
            error indication.</t>
          </section>

          <section title="transit delay">
            <t>The "transit delay" field is a 4-octet unsigned integer in the
            range 0 to 2^31-1. It is the time in nanoseconds the packet spent
            in the transit node. This can serve as an indication of the
            queuing delay at the node. If the transit delay exceeds 2^31-1
            nanoseconds then the top bit 'O' is set to indicate overflow and
            value set to 0x80000000. When this field is part of the data field
            but a node populating the field is not able to fill it, the field
            position in the field MUST be filled with value 0xFFFFFFFF to mean
            not populated.<figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|O|                     transit delay                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure></t>
          </section>

          <section title="namespace specific data">
            <t>The "namespace specific data" field is a 4-octet field which
            can be used by the node to add IOAM-Namespace specific data. This
            represents a "free-format" 4-octet bit field with its semantics
            defined in the context of a specific IOAM-Namespace.<figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    namespace specific data                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure></t>
          </section>

          <section title="queue depth">
            <t>The "queue depth" field is a 4-octet unsigned integer field.
            This field indicates the current length of the egress interface
            queue of the interface from where the packet is forwarded out. The
            queue depth is expressed as the current amount of memory buffers
            used by the queue (a packet could consume one or more memory
            buffers, depending on its size). <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       queue depth                             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure></t>
          </section>
          <section title="Checksum Complement">
            <t>The "Checksum Complement" field is a 4-octet node data which
            contains a 4-octet Checksum Complement field. The Checksum
            Complement is useful when IOAM is transported over encapsulations
            that make use of a UDP transport, such as VXLAN-GPE or Geneve.
            Without the Checksum Complement, nodes adding IOAM node data 
            update the UDP Checksum field following the recommendation of the
	    encapsulation protocols. When the Checksum Complement is
            present, an IOAM encapsulating node or IOAM transit node adding
            node data MUST carry out one of the following two alternatives in
            order to maintain the correctness of the UDP Checksum value: <list
                style="numbers">
                <t>Recompute the UDP Checksum field.</t>

                <t>Use the Checksum Complement to make a checksum-neutral
                update in the UDP payload; the Checksum Complement is assigned
                a value that complements the rest of the node data fields that
                were added by the current node, causing the existing UDP
                Checksum field to remain correct.</t>
              </list> IOAM decapsulating nodes MUST recompute the UDP Checksum
            field, since they do not know whether previous hops modified the
            UDP Checksum field or the Checksum Complement field. <vspace
            blankLines="1"/> Checksum Complement fields are used in a similar
            manner in <xref target="RFC7820"/> and <xref target="RFC7821"/>.
            <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Checksum Complement                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure></t>
          </section>
          <section title="Hop_Lim and node_id wide">
            <t>The "Hop_Lim and node_id wide" field is an 8-octet field
            defined as follows: <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Hop_Lim     |              node_id                          ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                         node_id (contd)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure><list style="hanging">
                <t hangText="Hop_Lim:">1-octet unsigned integer. It is set to
                the Hop Limit value in the packet at the node that records
                this data. Hop Limit information is used to identify the
                location of the node in the communication path. This is copied
                from the lower layer for e.g. TTL value in IPv4 header or hop
                limit field from IPv6 header of the packet. The semantics of
                the Hop_Lim field depend on the lower layer protocol that IOAM
                is encapsulated into, and therefore its specific semantics are
                outside the scope of this memo. The value of this field MUST
                be set to 0xff when the lower level does not have a TTL/Hop
                limit equivalent field.</t>

                <t hangText="node_id:">7-octet unsigned integer. Node
                identifier field to uniquely identify a node within the
                IOAM-Namespace and associated IOAM-Domain. The procedure to
                allocate, manage and map the node_ids is beyond the scope of
                this document.</t>
              </list></t>
          </section>

          <section title="ingress_if_id and egress_if_id wide">
            <t>The "ingress_if_id and egress_if_id wide" field is an 8-octet
            field which is defined as follows: <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       ingress_if_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       egress_if_id                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure><list style="hanging">
                <t hangText="ingress_if_id:">4-octet unsigned integer.
                Interface identifier to record the ingress interface the
                packet was received on.</t>

                <t hangText="egress_if_id:">4-octet unsigned integer.
                Interface identifier to record the egress interface the packet
                is forwarded out of.</t>
              </list></t>
          </section>

          <section title="namespace specific data wide">
            <t>The "namespace specific data wide" field is an 8-octet field
            which can be used by the node to add IOAM-Namespace specific data.
            This represents a "free-format" 8-octet bit field with its
            semantics defined in the context of a specific
            IOAM-Namespace.<figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    namespace specific data                    ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                namespace specific data (contd)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
              </figure></t>
          </section>

          <section title="buffer occupancy">
            <t>The "buffer occupancy" field is a 4-octet unsigned integer
            field. This field indicates the current status of the occupancy of
            the common buffer pool used by a set of queues. The units of this
            field are implementation specific. Hence, the units are
            interpreted within the context of an IOAM-Namespace and/or
            node-id if used. The authors acknowledge that in some operational
            cases there is a need for the units to be consistent across a
            packet path through the network, hence RECOMMEND the
            implementations to use standard units such as Bytes. <figure>
                <artwork><![CDATA[ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       buffer occupancy                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure></t>
          </section>

          <section title="Opaque State Snapshot">
            <t>The "Opaque State Snapshot" is a variable length field and
            follows the fixed length IOAM-Data-Fields defined above. It allows
            the network element to store an arbitrary state in the node data
            field, without a pre-defined schema. The schema is to be defined
            within the context of an IOAM-Namespace. The schema needs to be
            made known to the analyzer by some out-of-band mechanism. The
            specification of this mechanism is beyond the scope of this
            document. A 24-bit "Schema Id" field, interpreted within the
            context of an IOAM-Namespace, indicates which particular schema is
            used, and has to be configured on the network element by the
            operator.<figure>
                <artwork><![CDATA[    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Length      |                     Schema ID                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   |                                                               |
   |                        Opaque data                            |
   ~                                                               ~
   .                                                               .
   .                                                               .
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+]]></artwork>
              </figure><list style="hanging">
                <t hangText="Length:">1-octet unsigned integer. It is the
                length in multiples of 4-octets of the Opaque data field that
                follows Schema Id.</t>

                <t hangText="Schema ID:">3-octet unsigned integer identifying
                the schema of Opaque data.</t>

                <t hangText="Opaque data:">Variable length field. This field
                is interpreted as specified by the schema identified by the
                Schema ID.</t>
              </list>When this field is part of the data field but a node
            populating the field has no opaque state data to report, the
            Length MUST be set to 0 and the Schema ID MUST be set to 0xFFFFFF
            to mean no schema.</t>
          </section>
        </section>

        <section anchor="trace-type-node-data"
                 title=" Examples of IOAM node data">
          <t>An entry in the "node data list" array can have different
          formats, following the needs of the deployment. Some deployments
          might only be interested in recording the node identifiers, whereas
          others might be interested in recording node identifier and
          timestamp. The section provides example entries of the "node data
          list".</t>

          <t><list style="hanging">
              <t hangText="0xD40000:">IOAM-Trace-Type is 0xD40000
              (0b110101000000000000000000) then the format of node data
              is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     ingress_if_id             |         egress_if_id          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                     timestamp subseconds                      |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    namespace specific data                    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


]]></artwork>
                </figure></t>

              <t hangText="0xC00000:">IOAM-Trace-Type is 0xC00000
              (0b110000000000000000000000) then the format is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     ingress_if_id             |         egress_if_id          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
]]></artwork>
                </figure></t>

              <t hangText="0x900000:">IOAM-Trace-Type is 0x900000
              (0b100100000000000000000000) then the format is: <figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                   timestamp subseconds                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x840000:">IOAM-Trace-Type is 0x840000
              (0b100001000000000000000000) then the format is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    namespace specific data                    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x940000:">IOAM-Trace-Type is 0x940000
              (0b100101000000000000000000) then the format is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    timestamp subseconds                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    namespace specific data                    |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>

              <t hangText="0x308002:">IOAM-Trace-Type is 0x308002
              (0b001100001000000000000010) then the format is:<figure>
                  <artwork><![CDATA[     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                      timestamp seconds                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                    timestamp subseconds                       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Hop_Lim     |              node_id                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         node_id(contd)                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Length      |                     Schema Id                 |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                                                               |
    |                        Opaque data                            |
    ~                                                               ~
    .                                                               .
    .                                                               .
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
                </figure></t>
            </list></t>
        </section>
      </section>

      <section anchor="IOAM_proof_of_transit_option"
               title="IOAM Proof of Transit Option-Type">
        <t>IOAM Proof of Transit Option-Type is to support path or service
        function chain <xref target="RFC7665"/> verification use cases.
        Proof-of-transit leverages mechanisms like Shamir's Secret Sharing
        Schema (SSSS) <xref target="SSS"/>. For further information on
        Proof-of-transit, please refer to <xref
        target="I-D.ietf-sfc-proof-of-transit"/>. While details on how the
        IOAM data for the Proof-of-transit option is processed at IOAM
        encapsulating, decapsulating and transit nodes are outside the scope
        of the document, all of these approaches share the need to uniquely
        identify a packet as well as iteratively operate on a set of
        information that is handed from node to node. Correspondingly, two
        pieces of information are added as IOAM-Data-Fields to the packet:</t>

        <t><list style="symbols">
            <t>Random: Unique identifier for the packet (e.g., 64-bits allow
            for the unique identification of 2^64 packets).</t>

            <t>Cumulative: Information which is handed from node to node and
            updated by every node according to a verification algorithm.</t>
          </list>The IOAM Proof-of-Transit Option-Type consist of a fixed size
        "IOAM proof of transit option header" and "IOAM proof of transit
        option data fields":</t>

        <t><figure>
            <artwork><![CDATA[ 
IOAM proof of transit option header:
 
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Namespace-ID            |IOAM POT Type  | IOAM POT flags| 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

IOAM proof of transit Option-Type IOAM-Data-Fields MUST be 
4-octet aligned:
    
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       POT Option data field determined by IOAM-POT-Type       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


]]></artwork>
          </figure><list style="hanging">
            <t hangText="Namespace-ID:">16-bit identifier of an
            IOAM-Namespace. The Namespace-ID value of 0x0000 is defined as the
            default value and MUST be known to all the nodes implementing
            IOAM. For any other Namespace-ID value that does not match any
            Namespace-ID the node is configured to operate on, the node MUST
            NOT change the contents of the IOAM-Data-Fields.</t>

            <t hangText="IOAM POT Type:">8-bit identifier of a particular POT
            variant that specifies the POT data that is included. This
            document defines POT Type 0:<list style="hanging">
                <t hangText="0:">POT data is a 16 Octet field as described
                below.</t>
              </list>
            If a node receives an IOAM POT Type value that it does not
            understand, the node MUST NOT change the contents of the
            IOAM-Data-Fields.</t>

            <t hangText="IOAM POT flags:">8-bit. Following flags are
            defined:<list style="hanging">
                <t hangText="Bit 0">"Profile-to-use" (P-bit) (most significant
                bit). For IOAM POT types that use a maximum of two profiles to
                drive computation, indicates which POT-profile is used. The
                two profiles are numbered 0, 1.</t>

                <t hangText="Bit 1-7">Reserved: MUST be set to zero upon
                transmission and ignored upon receipt.</t>
              </list></t>

            <t hangText="POT Option data:">Variable-length field. The type of
            which is determined by the IOAM-POT-Type.</t>
          </list></t>

        <section title="IOAM Proof of Transit Type 0">
          <t><figure>
              <artwork><![CDATA[ 
IOAM proof of transit option of IOAM POT Type 0:
 
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Namespace-ID           |IOAM POT Type=0|P|R R R R R R R|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+
|                        Random                                 |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  P
|                        Random(contd)                          |  O
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  T
|                        Cumulative                             |  | 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                        Cumulative (contd)                     |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<-+


]]></artwork>
            </figure><list style="hanging">
              <t hangText="Namespace-ID:">16-bit identifier of an
              IOAM-Namespace. The Namespace-ID value of 0x0000 is defined as
              the default value and MUST be known to all the nodes
              implementing IOAM. For any other Namespace-ID value that does
              not match any Namespace-ID the node is configured to operate on,
              the node MUST NOT change the contents of the
              IOAM-Data-Fields.</t>

              <t hangText="IOAM POT Type:">8-bit identifier of a particular
              POT variant that specifies the POT data that is included. This
              section defines the POT data when the IOAM POT Type is set to
              the value 0.</t>

              <t hangText="P bit:">1-bit. "Profile-to-use" (P-bit) (most
              significant bit). Indicates which POT-profile is used to
              generate the Cumulative. Any node participating in POT will have
              a maximum of 2 profiles configured that drive the computation of
              cumulative. The two profiles are numbered 0, 1. This bit conveys
              whether profile 0 or profile 1 is used to compute the
              Cumulative.</t>

              <t hangText="R (7 bits):">7-bit IOAM POT flags for future use.
              MUST be set to zero upon transmission and ignored upon
              receipt.</t>

              <t hangText="Random:">64-bit Per packet Random number.</t>

              <t hangText="Cumulative:">64-bit Cumulative that is updated at
              specific nodes by processing per packet Random number field and
              configured parameters.</t>
            </list>Note: Larger or smaller sizes of "Random" and "Cumulative"
          data are feasible and could be required for certain deployments
          (e.g. in case of space constraints in the encapsulation protocols
          used). Future documents could introduce different sizes of data for
          "proof of transit".</t>
        </section>
      </section>

      <section anchor="IOAM_edge_to_edge_opt"
               title="IOAM Edge-to-Edge Option-Type">
        <t>The IOAM Edge-to-Edge Option-Type is to carry data that is added by
        the IOAM encapsulating node and interpreted by IOAM decapsulating
        node. The IOAM transit nodes MAY process the data but MUST NOT modify
        it.</t>

        <t>The IOAM Edge-to-Edge Option-Type consist of a fixed size "IOAM
        Edge-to-Edge Option-Type header" and "IOAM Edge-to-Edge Option-Type
        data fields":</t>

        <t><figure>
            <artwork><![CDATA[
IOAM Edge-to-Edge Option-Type header:
   
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        Namespace-ID           |         IOAM-E2E-Type         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

IOAM Edge-to-Edge Option-Type IOAM-Data-Fields MUST
be 4-octet aligned:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       E2E Option data field determined by IOAM-E2E-Type       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

]]></artwork>
          </figure><list style="hanging">
            <t hangText="Namespace-ID:">16-bit identifier of an
            IOAM-Namespace. The Namespace-ID value of 0x0000 is defined as the
            default value and MUST be known to all the nodes implementing
            IOAM. For any other Namespace-ID value that does not match any
            Namespace-ID the node is configured to operate on, then the node
            MUST NOT change the contents of the IOAM-Data-Fields.</t>

            <t hangText="IOAM-E2E-Type:">A 16-bit identifier which specifies
            which data types are used in the E2E option data. The
            IOAM-E2E-Type value is a bit field. The order of packing the E2E
            option data field elements follows the bit order of the
            IOAM-E2E-Type field, as follows:<list hangIndent="9"
                style="hanging">
                <t hangText="Bit 0">(Most significant bit) When set indicates
                presence of a 64-bit sequence number added to a specific
                "packet group" which is used to detect packet loss, packet
                reordering, or packet duplication within the group. The
                "packet group" is deployment dependent and defined at the IOAM
                encapsulating node e.g. by n-tuple based classification of
                packets.</t>

                <t hangText="Bit 1">When set indicates presence of a 32-bit
                sequence number added to a specific "packet group" which is
                used to detect packet loss, packet reordering, or packet
                duplication within that group. The "packet group" is
                deployment dependent and defined at the IOAM encapsulating
                node e.g. by n-tuple based classification of packets.</t>

                <t hangText="Bit 2">When set indicates presence of timestamp
                seconds, representing the time at which the packet entered the
                IOAM domain. Within the IOAM encapsulating node, the time that
                the timestamp is retrieved can depend on the implementation.
                Some possibilities are: 1) the time at which the packet was
                received by the node, 2) the time at which the packet was
                transmitted by the node, 3) when a tunnel encapsulation is
                used, the point at which the packet is encapsulated into the
                tunnel. Each implementation has to document when the E2E
                timestamp that is going to be put in the packet is retrieved.
                This 4-octet field has three possible formats; based on either
                PTP <xref target="IEEE1588v2"/>, NTP <xref target="RFC5905"/>,
                or POSIX <xref target="POSIX"/>. The three timestamp formats
                are specified in <xref target="TimestampSec"/>. In all three
                cases, the Timestamp Seconds field contains the 32 most
                significant bits of the timestamp format that is specified in
                <xref target="TimestampSec"/>. If a node is not capable of
                populating this field, it assigns the value 0xFFFFFFFF. Note
                that this is a legitimate value that is valid for 1 second in
                approximately 136 years; the analyzer has to correlate several
                packets or compare the timestamp value to its own time-of-day
                in order to detect the error indication.</t>

                <t hangText="Bit 3">When set indicates presence of timestamp
                subseconds, representing the time at which the packet entered
                the IOAM domain. This 4-octet field has three possible
                formats; based on either PTP <xref target="IEEE1588v2"/>, NTP
                <xref target="RFC5905"/>, or POSIX <xref target="POSIX"/>. The
                three timestamp formats are specified in <xref
                target="TimestampSec"/>. In all three cases, the Timestamp
                Subseconds field contains the 32 least significant bits of the
                timestamp format that is specified in <xref
                target="TimestampSec"/>. If a node is not capable of
                populating this field, it assigns the value 0xFFFFFFFF. Note
                that this is a legitimate value in the NTP format, valid for
                approximately 233 picoseconds in every second. If the NTP
                format is used the analyzer has to correlate several packets
                in order to detect the error indication.</t>

                <t hangText="Bit 4-15">Undefined. An IOAM encapsulating node
                MUST set the value of these bits to zero upon transmission and
                ignore upon receipt.</t>
              </list></t>

            <t hangText="E2E Option data:">Variable-length field. The type of
            which is determined by the IOAM-E2E-Type.</t>
          </list></t>
      </section>
    </section>

    <section anchor="TimestampSec" title="Timestamp Formats">
      <t>The IOAM-Data-Fields include a timestamp field which is represented
      in one of three possible timestamp formats. It is assumed that the
      management plane is responsible for determining which timestamp format
      is used.</t>

      <section anchor="PTPFromatSec" title="PTP Truncated Timestamp Format">
        <t>The Precision Time Protocol (PTP) <xref target="IEEE1588v2"/> uses
        an 80-bit timestamp format. The truncated timestamp format is a 64-bit
        field, which is the 64 least significant bits of the 80-bit PTP
        timestamp. The PTP truncated format is specified in Section 4.3 of
        <xref target="I-D.ietf-ntp-packet-timestamps"/>, and the details are
        presented below for the sake of completeness.</t>

        <figure align="center" anchor="PTPFormat"
                title="PTP [IEEE1588v2] Truncated Timestamp Format">
          <artwork align="left"><![CDATA[
         
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Seconds                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Nanoseconds                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           ]]></artwork>
        </figure>

        <t>Timestamp field format: <list hangIndent="10" style="empty">
            <t>Seconds: specifies the integer portion of the number of seconds
            since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: seconds.</t>

            <t>Nanoseconds: specifies the fractional portion of the number of
            seconds since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: nanoseconds. The value of this field is in the range 0
            to (10^9)-1.</t>
          </list></t>

        <t>Epoch: <list hangIndent="10" style="empty">
            <t>The PTP <xref target="IEEE1588v2"/> epoch is 1 January 1970
            00:00:00 TAI, which is 31 December 1969 23:59:51.999918 UTC.</t>
          </list></t>

        <t>Resolution: <list hangIndent="10" style="empty">
            <t>The resolution is 1 nanosecond.</t>
          </list></t>

        <t>Wraparound: <list hangIndent="10" style="empty">
            <t>This time format wraps around every 2^32 seconds, which is
            roughly 136 years. The next wraparound will occur in the year
            2106.</t>
          </list></t>

        <t>Synchronization Aspects: <list hangIndent="10" style="empty">
            <t>It is assumed that nodes that run this protocol are
            synchronized among themselves. Nodes MAY be synchronized to a
            global reference time. Note that if PTP <xref
            target="IEEE1588v2"/> is used for synchronization, the timestamp
            MAY be derived from the PTP-synchronized clock, allowing the
            timestamp to be measured with respect to the clock of an PTP
            Grandmaster clock.</t>

            <t>The PTP truncated timestamp format is not affected by leap
            seconds.</t>
          </list></t>
      </section>

      <section anchor="NTPFormatSec" title="NTP 64-bit Timestamp Format">
        <t>The Network Time Protocol (NTP) <xref target="RFC5905"/> timestamp
        format is 64 bits long. This format is specified in Section 4.2.1 of
        <xref target="I-D.ietf-ntp-packet-timestamps"/>, and the details are
        presented below for the sake of completeness.</t>

        <figure align="center" anchor="NTPFormat"
                title="NTP [RFC5905] 64-bit Timestamp Format">
          <artwork align="left"><![CDATA[
         
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Seconds                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Fraction                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           ]]></artwork>
        </figure>

        <t>Timestamp field format: <list hangIndent="10" style="empty">
            <t>Seconds: specifies the integer portion of the number of seconds
            since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: seconds.</t>

            <t>Fraction: specifies the fractional portion of the number of
            seconds since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: the unit is 2^(-32) seconds, which is roughly equal to
            233 picoseconds.</t>
          </list></t>

        <t>Epoch: <list hangIndent="10" style="empty">
            <t>The epoch is 1 January 1900 at 00:00 UTC.</t>
          </list></t>

        <t>Resolution: <list hangIndent="10" style="empty">
            <t>The resolution is 2^(-32) seconds.</t>
          </list></t>

        <t>Wraparound: <list hangIndent="10" style="empty">
            <t>This time format wraps around every 2^32 seconds, which is
            roughly 136 years. The next wraparound will occur in the year
            2036.</t>
          </list></t>

        <t>Synchronization Aspects: <list hangIndent="10" style="empty">
            <t>Nodes that use this timestamp format will typically be
            synchronized to UTC using NTP <xref target="RFC5905"/>. Thus, the
            timestamp MAY be derived from the NTP-synchronized clock, allowing
            the timestamp to be measured with respect to the clock of an NTP
            server.</t>

            <t>The NTP timestamp format is affected by leap seconds; it
            represents the number of seconds since the epoch minus the number
            of leap seconds that have occurred since the epoch. The value of a
            timestamp during or slightly after a leap second could be
            temporarily inaccurate.</t>
          </list></t>
      </section>

      <section anchor="POSIXFormatSec" title="POSIX-based Timestamp Format">
        <t>This timestamp format is based on the POSIX time format <xref
        target="POSIX"/>. The detailed specification of the timestamp format
        used in this document is presented below.</t>

        <figure align="center" anchor="POSIXFormat"
                title="POSIX-based Timestamp Format">
          <artwork align="left"><![CDATA[
         
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                            Seconds                            |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                          Microseconds                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           ]]></artwork>
        </figure>

        <t>Timestamp field format: <list hangIndent="10" style="empty">
            <t>Seconds: specifies the integer portion of the number of seconds
            since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: seconds.</t>

            <t>Microseconds: specifies the fractional portion of the number of
            seconds since the epoch.</t>

            <t>+ Size: 32 bits.</t>

            <t>+ Units: the unit is microseconds. The value of this field is
            in the range 0 to (10^6)-1.</t>
          </list></t>

        <t>Epoch: <list hangIndent="10" style="empty">
            <t>The epoch is 1 January 1970 00:00:00 TAI, which is 31 December
            1969 23:59:51.999918 UTC.</t>
          </list></t>

        <t>Resolution: <list hangIndent="10" style="empty">
            <t>The resolution is 1 microsecond.</t>
          </list></t>

        <t>Wraparound: <list hangIndent="10" style="empty">
            <t>This time format wraps around every 2^32 seconds, which is
            roughly 136 years. The next wraparound will occur in the year
            2106.</t>
          </list></t>

        <t>Synchronization Aspects: <list hangIndent="10" style="empty">
            <t>It is assumed that nodes that use this timestamp format run the
            Linux operating system, and hence use the POSIX time. In some
            cases nodes MAY be synchronized to UTC using a synchronization
            mechanism that is outside the scope of this document, such as NTP
            <xref target="RFC5905"/>. Thus, the timestamp MAY be derived from
            the NTP-synchronized clock, allowing the timestamp to be measured
            with respect to the clock of an NTP server.</t>

            <t>The POSIX-based timestamp format is affected by leap seconds;
            it represents the number of seconds since the epoch minus the
            number of leap seconds that have occurred since the epoch. The
            value of a timestamp during or slightly after a leap second could be
            temporarily inaccurate.</t>
          </list></t>
      </section>
    </section>

    <section anchor="export" title="IOAM Data Export">
      <t>IOAM nodes collect information for packets traversing a domain that
      supports IOAM. IOAM decapsulating nodes as well as IOAM transit nodes
      can choose to retrieve IOAM information from the packet, process the
      information further and export the information using e.g., IPFIX. The
      mechanisms and associated data formats for exporting IOAM data is
      outside the scope of this document.</t>

      <t>Raw data export of IOAM data using IPFIX is discussed in <xref
      target="I-D.spiegel-ippm-ioam-rawexport"/>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document requests the following IANA Actions.</t>

      <t>IANA is requested to define a registry group named
	  "In-Situ OAM (IOAM) Protocol Parameters".</t>

	  <t>This group will include the following registries:</t>

        <t><list style="empty">
            <t>IOAM Option-Type</t>

            <t>IOAM Trace-Type</t>

            <t>IOAM Trace-Flags</t>

            <t>IOAM POT-Type</t>

            <t>IOAM POT-Flags</t>

            <t>IOAM E2E-Type</t>

            <t>IOAM Namespace-ID</t>
          </list></t>

        <t>New registries in this group can be created via RFC
        Required process as per <xref target="RFC8126"/>.</t>

        <t>The subsequent sub-sections detail the registries herein
        contained.</t>

      <section anchor="IOAM-type-registry" title="IOAM Option-Type Registry">
        <t>This registry defines 128 code points for the IOAM Option-Type
        field for identifying IOAM Option-Types as explained in <xref
        target="IOAM_option_format"/>. The following code points are defined
        in this draft:</t>

        <t><list style="hanging">
            <t hangText="0">IOAM Pre-allocated Trace Option-Type</t>

            <t hangText="1">IOAM Incremental Trace Option-Type</t>

            <t hangText="2">IOAM POT Option-Type</t>

            <t hangText="3">IOAM E2E Option-Type</t>
          </list>4 - 127 are available for assignment via RFC Required process
        as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM Trace-Type Registry">
        <t>This registry defines code point for each bit in the 24-bit
        IOAM-Trace-Type field for Pre-allocated trace option and Incremental
        trace option defined in <xref target="IOAM_tracing_option"/>. The
        meaning of Bits 0 - 11 for trace type are defined in this document in
        <xref target="IOAMTraceType"/> of <xref target="TraceOptionDef"/>:</t>

        <t><list style="hanging">
            <t hangText="Bit 0">hop_Lim and node_id in short format</t>

            <t hangText="Bit 1">ingress_if_id and egress_if_id in short
            format</t>

            <t hangText="Bit 2">timestamp seconds</t>

            <t hangText="Bit 3">timestamp subseconds</t>

            <t hangText="Bit 4">transit delay</t>

            <t hangText="Bit 5">namespace specific data in short format</t>

            <t hangText="Bit 6">queue depth</t>

            <t hangText="Bit 7">checksum complement</t>

            <t hangText="Bit 8">hop_Lim and node_id in wide format</t>

            <t hangText="Bit 9">ingress_if_id and egress_if_id in wide
            format</t>

            <t hangText="Bit 10">namespace specific data in wide format</t>

            <t hangText="Bit 11">buffer occupancy</t>

            <t hangText="Bit 22">variable length Opaque State Snapshot</t>

            <t hangText="Bit 23">reserved</t>
          </list> The meaning for Bits 12 - 21 are available for assignment
        via RFC Required process as per <xref target="RFC8126"/>.</t>
      </section>

      <section anchor="Flags-Registry-Sec" title="IOAM Trace-Flags Registry">
        <t>This registry defines code points for each bit in the 4 bit flags
        for the Pre-allocated trace option and for the Incremental trace
        option defined in <xref target="IOAM_tracing_option"/>. The meaning of
        Bit 0 (the most significant bit) for trace flags is defined in this
        document in <xref target="TraceFlags"/> of <xref
        target="TraceOptionDef"/>:</t>

        <t><list style="hanging">
            <t hangText="Bit 0">"Overflow" (O-bit)</t>
          </list>Bit 1 - 3 are available for assignment via RFC Required
        process as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM POT-Type Registry">
        <t>This registry defines 256 code points to define IOAM POT Type for
        IOAM proof of transit option <xref
        target="IOAM_proof_of_transit_option"/>. The code point value 0 is
        defined in this document:</t>

        <t><list style="hanging">
            <t hangText="0:">16 Octet POT data</t>
          </list> 1 - 255 are available for assignment via RFC Required
        process as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM POT-Flags Registry">
        <t>This registry defines code points for each bit in the 8 bit flags
        for IOAM POT option defined in <xref
        target="IOAM_proof_of_transit_option"/>. The meaning of Bit 0 for IOAM
        POT flags is defined in this document in <xref
        target="IOAM_proof_of_transit_option"/>:</t>

        <t><list style="hanging">
            <t hangText="Bit 0">"Profile-to-use" (P-bit)</t>
          </list> The meaning for Bits 1 - 7 are available for assignment via
        RFC Required process as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM E2E-Type Registry">
        <t>This registry defines code points for each bit in the 16 bit
        IOAM-E2E-Type field for IOAM E2E option <xref
        target="IOAM_edge_to_edge_opt"/>. The meaning of Bit 0 - 3 are defined
        in this document:</t>

        <t><list style="hanging">
            <t hangText="Bit 0">64-bit sequence number</t>

            <t hangText="Bit 1">32-bit sequence number</t>

            <t hangText="Bit 2">timestamp seconds</t>

            <t hangText="Bit 3">timestamp subseconds</t>
          </list> The meaning of Bits 4 - 15 are available for assignment via
        RFC Required process as per <xref target="RFC8126"/>.</t>
      </section>

      <section title="IOAM Namespace-ID Registry ">
        <t>IANA is requested to set up an "IOAM Namespace-ID Registry",
        containing 16-bit values. The meaning of Bit 0 is defined in this
        document. IANA is requested to reserve the values 0x0001 to 0x7FFF for
        private use (managed by operators), as specified in <xref
        target="ioam_namespaces"/> of the current document. Registry entries
        for the values 0x8000 to 0xFFFF are to be assigned via the "Expert
        Review" policy defined in <xref target="RFC8126"/>. Upon a new 
		allocation request, the responsible AD will appoint a designated 
		expert, who will review the allocation request. The expert will post 
		the request on the IPPM mailing list, and possibly on other relevant 
		mailing lists, to allow for community feedback. Based on the review, 
		the expert will either approve or deny the request. The intention is 
		that any allocation will be accompanied by a published RFC.  But in 
		order to allow for the allocation of values prior to the RFC being 
		approved for publication, the designated expert can approve 
		allocations once it seems clear that an RFC will be published.</t>

        <t><list style="hanging">
            <t hangText="0:">default namespace (known to all IOAM nodes)</t>

            <t hangText="0x0001 - 0x7FFF:">reserved for private use</t>

            <t hangText="0x8000 - 0xFFFF:">unassigned</t>
          </list></t>
      </section>
    </section>

    <section title="Management and Deployment Considerations">
	    <t>This document defines the structure and use of IOAM data fields. 
	This document does not define the encapsulation of IOAM data fields into different protocols.
	Management and deployment aspects for IOAM have to be considered within the context of the
	protocol IOAM data fields are encapsulated into and as such, are out of scope for this document.
	For a discussion of IOAM deployment, please also refer to
	<xref target="I-D.brockners-opsawg-ioam-deployment"/>, which outlines a framework for IOAM deployment
       	and provides best current practices.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>As discussed in <xref target="RFC7276"/>, a successful attack on an
      OAM protocol in general, and specifically on IOAM, can prevent the
      detection of failures or anomalies, or create a false illusion of
      nonexistent ones. In particular, these threats are applicable by
      compromising the integrity of IOAM data, either by maliciously modifying
      IOAM options in transit, or by injecting packets with maliciously
      generated IOAM options</t>

      <t>The Proof of Transit Option-Type (Section <xref
      target="IOAM_proof_of_transit_option"/>) is used for verifying the path
      of data packets. The security considerations of POT are further
      discussed in <xref target="I-D.ietf-sfc-proof-of-transit"/>.</t>

      <t>From a confidentiality perspective, although IOAM options do not
      contain user data, they can be used for network reconnaissance, allowing
      attackers to collect information about network paths, performance, queue
      states, buffer occupancy and other information. Moreover, if IOAM data
      leaks from the IOAM domain it could enable reconnaissance beyond the scope
      of the IOAM domain. Note that in case IOAM is used in "Direct Exporting"
      mode <xref target="I-D.ioamteam-ippm-ioam-direct-export"/>, the IOAM
      related trace information would not be available in the customer data
      packets, but would trigger export of packet related IOAM information at
      every node, thus restricting the potential threat to the management
      plane and mitigating the leakage threat. IOAM data exporting and the way
      it is secured is outside the scope of this document.</t>

      <t>IOAM can be used as a means for implementing Denial of Service (DoS)
      attacks, or for amplifying them. For example, a malicious attacker can
      add an IOAM header to packets in order to consume the resources of
      network devices that take part in IOAM or entities that receive, collect
      or analyze the IOAM data. Another example is a packet length attack, in
      which an attacker pushes headers associated with IOAM Option-Types into
      data packets, causing these packets to be increased beyond the MTU size,
      resulting in fragmentation or in packet drops.</t>

      <t>Since IOAM options can include timestamps, if network devices use
      synchronization protocols then any attack on the time protocol <xref
      target="RFC7384"/> can compromise the integrity of the timestamp-related
      data fields.</t>

      <t>At the management plane, attacks can be set up by misconfiguring
      or by maliciously configuring IOAM-enabled nodes in a way that enables
      other attacks. Thus, IOAM configuration has to be secured in a way that
      authenticates authorized users and verifies the integrity of
      configuration procedures.</t>

      <t>The current document does not define a specific IOAM encapsulation.
      It has to be noted that some IOAM encapsulation types can introduce
      specific security considerations. A specification that defines an IOAM
      encapsulation is expected to address the respective
      encapsulation-specific security considerations.</t>

      <t>Notably, in most cases IOAM is expected to be deployed in specific
      network domains, thus confining the potential attack vectors to within
      the network domain. A limited administrative domain provides the
      operator with the means to select, monitor, and control the access of
      all the network devices, making these devices trusted by the operator.
      Indeed, in order to limit the scope of threats mentioned above to within
      the current network domain the network operator is expected to enforce
      policies that prevent IOAM traffic from leaking outside of the IOAM
      domain, and prevent IOAM data from outside the domain to be processed
      and used within the domain.</t>

      <t>The security considerations of a system that deploys IOAM, much like
      any system, has to be reviewed on a per-deployment-scenario basis, based
      on a systems-specific threat analysis, which can lead to specific
      security solutions that are beyond the scope of the current document.
      For example, in an IOAM deployment that is not confined to a single LAN,
      but spans multiple inter-connected sites, the inter-site links can be
      secured (e.g., by IPsec) in order to avoid external threats.</t>
    </section>

    <section title="Acknowledgements">
      <t>The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
      Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
      Nadahalli, LJ Wobker, Erik Nordmark, Vengada Prasad Govindan, Andrew
      Yourtchenko, Aviv Kfir, Tianran Zhou and Zhenbin (Robin) for the
      comments and advice.</t>

      <t>This document leverages and builds on top of several concepts
      described in <xref target="I-D.kitamura-ipv6-record-route"/>. The
      authors would like to acknowledge the work done by the author Hiroshi
      Kitamura and people involved in writing it.</t>

      <t>The authors would like to gracefully acknowledge useful review and
      insightful comments received from Joe Clarke, Al Morton, Tom Herbert,
      Haoyu Song, Mickey Spiegel and Barak Gafni.</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;

      &RFC5905;

      &RFC8126;

      <reference anchor="POSIX"
                 target="https://standards.ieee.org/findstds/standard/1003.1-2008.html">
        <front>
          <title>IEEE Std 1003.1-2008 (Revision of IEEE Std 1003.1-2004) -
          IEEE Standard for Information Technology - Portable Operating System
          Interface (POSIX(R))</title>

          <author>
            <organization>Institute of Electrical and Electronics
            Engineers</organization>
          </author>

          <date year="2008"/>
        </front>

        <seriesInfo name="" value="IEEE Std 1003.1-2008"/>
      </reference>

      <reference anchor="IEEE1588v2"
                 target="http://standards.ieee.org/findstds/standard/1588-2008.html">
        <front>
          <title>IEEE Std 1588-2008 - IEEE Standard for a Precision Clock
          Synchronization Protocol for Networked Measurement and Control
          Systems</title>

          <author>
            <organization>Institute of Electrical and Electronics
            Engineers</organization>
          </author>

          <date year="2008"/>
        </front>

        <seriesInfo name="" value="IEEE Std 1588-2008"/>
      </reference>
    </references>

    <references title="Informative References">
      &RFC7665;

      &RFC7799;

      &RFC7820;

      &RFC7821;

      &RFC7384;

      &RFC7276;

      <reference anchor="I-D.kitamura-ipv6-record-route">
        <front>
          <title>Record Route for IPv6 (PR6) Hop-by-Hop Option
          Extension</title>

          <author fullname="Hiroshi Kitamura" initials="H" surname="Kitamura"/>

          <date month="November" year="2000"/>
        </front>

        <seriesInfo name="Internet-Draft"
                    value="draft-kitamura-ipv6-record-route-00"/>

        <format target="https://tools.ietf.org/id/draft-kitamura-ipv6-record-route-00.txt"
                type="TXT"/>
      </reference>

      &RFC8300;

      &I-D.ietf-nvo3-vxlan-gpe;

      &I-D.ietf-nvo3-geneve;

      &I-D.ietf-ntp-packet-timestamps;

      &I-D.ietf-sfc-proof-of-transit;

      &I-D.ioamteam-ippm-ioam-direct-export;

      &I-D.spiegel-ippm-ioam-rawexport;

      &I-D.brockners-opsawg-ioam-deployment;

      <reference anchor="SSS"
                 target="https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing">
        <front>
          <title>Shamir's Secret Sharing</title>

          <author fullname="Wikipedia"/>

          <date/>
        </front>
      </reference>
    </references>
	
    <section numbered="no" title="Contributors' Addresses">
          <t><figure>
              <artwork><![CDATA[ 
   Carlos Pignataro
   Cisco Systems, Inc.
   7200-11 Kit Creek Road
   Research Triangle Park, NC  27709
   United States

   Email: cpignata@cisco.com

   
   Mickey Spiegel
   Barefoot Networks, an Intel company
   4750 Patrick Henry Drive
   Santa Clara, CA  95054
   US

   Email: mickey.spiegel@intel.com   

   
   Barak Gafni
   Mellanox Technologies, Inc.
   350 Oakmead Parkway, Suite 100
   Sunnyvale, CA  94085
   U.S.A.

   Email: gbarak@mellanox.com

   
   Jennifer Lemon
   Broadcom
   270 Innovation Drive
   San Jose, CA  95134
   US

   Email: jennifer.lemon@broadcom.com

   
   Hannes Gredler
   RtBrick Inc.

   Email: hannes@rtbrick.com


   John Leddy
   United States

   Email: john@leddy.net


   Stephen Youell
   JP Morgan Chase
   25 Bank Street
   London  E14 5JP
   United Kingdom

   Email: stephen.youell@jpmorgan.com


   David Mozes

   Email: mosesster@gmail.com


   Petr Lapukhov
   Facebook
   1 Hacker Way
   Menlo Park, CA  94025
   US

   Email: petr@fb.com


   Remy Chang
   Barefoot Networks
   4750 Patrick Henry Drive
   Santa Clara, CA  95054
   US

   Email: remy@barefootnetworks.com


   Daniel Bernier
   Bell Canada
   Canada

   Email: daniel.bernier@bell.ca

]]></artwork>
            </figure></t>	
	
    </section>
	
  </back>
</rfc>
